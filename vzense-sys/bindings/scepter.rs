/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
#[doc = "!< Depth frame with 16 bits per pixel in millimeters."]
pub const ScFrameType_SC_DEPTH_FRAME: ScFrameType = 0;
#[doc = "!< IR frame with 8 bits per pixel."]
pub const ScFrameType_SC_IR_FRAME: ScFrameType = 1;
#[doc = "!< Color frame with 24 bits per pixel in RGB/BGR format."]
pub const ScFrameType_SC_COLOR_FRAME: ScFrameType = 3;
#[doc = "!< Color frame with 24 bits per pixel in RGB/BGR format, that is transformed to depth\n!< sensor space where the resolution is the same as the depth frame's resolution.\n!< This frame type can be enabled using ::scSetTransformColorImgToDepthSensorEnabled()."]
pub const ScFrameType_SC_TRANSFORM_COLOR_IMG_TO_DEPTH_SENSOR_FRAME: ScFrameType = 4;
#[doc = "!< Depth frame with 16 bits per pixel, in millimeters, that is transformed to color sensor\n!< space where the resolution is same as the color frame's resolution.\n!< This frame type can be enabled using ::scSetTransformDepthImgToColorSensorEnabled()."]
pub const ScFrameType_SC_TRANSFORM_DEPTH_IMG_TO_COLOR_SENSOR_FRAME: ScFrameType = 5;
#[doc = " @brief    Specifies the type of image frame."]
pub type ScFrameType = ::std::os::raw::c_uint;
#[doc = "!< Depth image pixel format, 16 bits per pixel in mm."]
pub const ScPixelFormat_SC_PIXEL_FORMAT_DEPTH_MM16: ScPixelFormat = 0;
#[doc = "!< Gray image pixel format, 8 bits per pixel."]
pub const ScPixelFormat_SC_PIXEL_FORMAT_GRAY_8: ScPixelFormat = 2;
#[doc = "!< By jpeg decompress, color image pixel format, 24 bits per pixel RGB format."]
pub const ScPixelFormat_SC_PIXEL_FORMAT_RGB_888_JPEG: ScPixelFormat = 3;
#[doc = "!< By jpeg decompress, color image pixel format, 24 bits per pixel BGR format."]
pub const ScPixelFormat_SC_PIXEL_FORMAT_BGR_888_JPEG: ScPixelFormat = 4;
#[doc = "!< Without compress, color image pixel format, 24 bits per pixel RGB format."]
pub const ScPixelFormat_SC_PIXEL_FORMAT_RGB_888: ScPixelFormat = 5;
#[doc = "!< Without compress, color image pixel format, 24 bits per pixel BGR format."]
pub const ScPixelFormat_SC_PIXEL_FORMAT_BGR_888: ScPixelFormat = 6;
#[doc = "!< Without compress, color image pixel format, 16 bits per pixel RGB format."]
pub const ScPixelFormat_SC_PIXEL_FORMAT_RGB_565: ScPixelFormat = 7;
#[doc = "!< Without compress, color image pixel format, 16 bits per pixel BGR format."]
pub const ScPixelFormat_SC_PIXEL_FORMAT_BGR_565: ScPixelFormat = 8;
#[doc = " @brief    Specifies the image pixel format."]
pub type ScPixelFormat = ::std::os::raw::c_uint;
#[doc = "!< ToF camera."]
pub const ScSensorType_SC_TOF_SENSOR: ScSensorType = 1;
#[doc = "!< Color camera."]
pub const ScSensorType_SC_COLOR_SENSOR: ScSensorType = 2;
#[doc = " @brief    Specifies the type of sensor."]
pub type ScSensorType = ::std::os::raw::c_uint;
#[doc = "!< The function completed successfully."]
pub const ScStatus_SC_OK: ScStatus = 0;
#[doc = "!< The device is limbo"]
pub const ScStatus_SC_DEVICE_IS_LIMBO: ScStatus = -1;
#[doc = "!< The input device index is invalid."]
pub const ScStatus_SC_INVALID_DEVICE_INDEX: ScStatus = -2;
#[doc = "!< The device structure pointer is null."]
pub const ScStatus_SC_DEVICE_POINTER_IS_NULL: ScStatus = -3;
#[doc = "!< The input frame type is invalid."]
pub const ScStatus_SC_INVALID_FRAME_TYPE: ScStatus = -4;
#[doc = "!< The output frame buffer is null."]
pub const ScStatus_SC_FRAME_POINTER_IS_NULL: ScStatus = -5;
#[doc = "!< Cannot get the value for the specified property."]
pub const ScStatus_SC_NO_PROPERTY_VALUE_GET: ScStatus = -6;
#[doc = "!< Cannot set the value for the specified property."]
pub const ScStatus_SC_NO_PROPERTY_VALUE_SET: ScStatus = -7;
#[doc = "!< The input property value buffer pointer is null."]
pub const ScStatus_SC_PROPERTY_POINTER_IS_NULL: ScStatus = -8;
#[doc = "!< The input property value buffer size is too small to store the specified property value."]
pub const ScStatus_SC_PROPERTY_SIZE_NOT_ENOUGH: ScStatus = -9;
#[doc = "!< The input depth range mode is invalid."]
pub const ScStatus_SC_INVALID_DEPTH_RANGE: ScStatus = -10;
#[doc = "!< Capture the next image frame time out."]
pub const ScStatus_SC_GET_FRAME_READY_TIME_OUT: ScStatus = -11;
#[doc = "!< An input pointer parameter is null."]
pub const ScStatus_SC_INPUT_POINTER_IS_NULL: ScStatus = -12;
#[doc = "!< The camera has not been opened."]
pub const ScStatus_SC_CAMERA_NOT_OPENED: ScStatus = -13;
#[doc = "!< The specified type of camera is invalid."]
pub const ScStatus_SC_INVALID_CAMERA_TYPE: ScStatus = -14;
#[doc = "!< One or more of the parameter values provided are invalid."]
pub const ScStatus_SC_INVALID_PARAMS: ScStatus = -15;
#[doc = "!< This feature is not supported in the current version."]
pub const ScStatus_SC_CURRENT_VERSION_NOT_SUPPORT: ScStatus = -16;
#[doc = "!< There is an error in the upgrade file."]
pub const ScStatus_SC_UPGRADE_IMG_ERROR: ScStatus = -17;
#[doc = "!< Upgrade file path length greater than 260."]
pub const ScStatus_SC_UPGRADE_IMG_PATH_TOO_LONG: ScStatus = -18;
#[doc = "!< scSetUpgradeStatusCallback is not called."]
pub const ScStatus_SC_UPGRADE_CALLBACK_NOT_SET: ScStatus = -19;
#[doc = "!< The current product does not support this operation."]
pub const ScStatus_SC_PRODUCT_NOT_SUPPORT: ScStatus = -20;
#[doc = "!< No product profile found."]
pub const ScStatus_SC_NO_CONFIG_FOLDER: ScStatus = -21;
#[doc = "!< WebServer Start/Restart error(IP or PORT 8080)."]
pub const ScStatus_SC_WEB_SERVER_START_ERROR: ScStatus = -22;
#[doc = "!< The time from frame ready to get frame is out of 1s."]
pub const ScStatus_SC_GET_OVER_STAY_FRAME: ScStatus = -23;
#[doc = "!< Create log directory error."]
pub const ScStatus_SC_CREATE_LOG_DIR_ERROR: ScStatus = -24;
#[doc = "!< Create log file error."]
pub const ScStatus_SC_CREATE_LOG_FILE_ERROR: ScStatus = -25;
#[doc = "!< There is no adapter connected."]
pub const ScStatus_SC_NO_ADAPTER_CONNECTED: ScStatus = -100;
#[doc = "!< The SDK has been Initialized."]
pub const ScStatus_SC_REINITIALIZED: ScStatus = -101;
#[doc = "!< The SDK has not been Initialized."]
pub const ScStatus_SC_NO_INITIALIZED: ScStatus = -102;
#[doc = "!< The camera has been opened."]
pub const ScStatus_SC_CAMERA_OPENED: ScStatus = -103;
#[doc = "!< Set/Get cmd control error."]
pub const ScStatus_SC_CMD_ERROR: ScStatus = -104;
#[doc = "!< Set cmd ok.but time out for the sync return."]
pub const ScStatus_SC_CMD_SYNC_TIME_OUT: ScStatus = -105;
#[doc = "!< IP is not in the same network segment."]
pub const ScStatus_SC_IP_NOT_MATCH: ScStatus = -106;
#[doc = "!< Please invoke scStopStream first to close the data stream."]
pub const ScStatus_SC_NOT_STOP_STREAM: ScStatus = -107;
#[doc = "!< Please invoke scStartStream first to get the data stream."]
pub const ScStatus_SC_NOT_START_STREAM: ScStatus = -108;
#[doc = "!< Please check whether the Drivers directory exists."]
pub const ScStatus_SC_NOT_FIND_DRIVERS_FOLDER: ScStatus = -109;
#[doc = "!< The camera is openin,by another Sc_OpenDeviceByXXX API."]
pub const ScStatus_SC_CAMERA_OPENING: ScStatus = -110;
#[doc = "!< The camera has been opened by another APP."]
pub const ScStatus_SC_CAMERA_OPENED_BY_ANOTHER_APP: ScStatus = -111;
#[doc = "!< Capture the next AI result time out."]
pub const ScStatus_SC_GET_AI_RESULT_TIME_OUT: ScStatus = -112;
#[doc = "!< The morph Al library is not exist or initialized failed."]
pub const ScStatus_SC_MORPH_AI_LIB_ERROR: ScStatus = -113;
#[doc = "!< The cpu affinity config file check failed"]
pub const ScStatus_SC_CPU_AFFINITY_CHECK_FAILED: ScStatus = -114;
#[doc = "!< An unknown error occurred."]
pub const ScStatus_SC_OTHERS: ScStatus = -255;
#[doc = " @brief    Return status codes for all APIs.\n           <code>SC_OK = 0</code> means the API successfully completed its operation.\n           All other codes indicate a device, parameter, or API usage error."]
pub type ScStatus = ::std::os::raw::c_int;
#[doc = "!< Unknown device status and cannot try to open."]
pub const ScConnectStatus_SC_LIMBO: ScConnectStatus = 0;
#[doc = "!< Device connectable state and support open."]
pub const ScConnectStatus_SC_CONNECTABLE: ScConnectStatus = 1;
#[doc = "!< The device is connected and cannot be opened again."]
pub const ScConnectStatus_SC_OPENED: ScConnectStatus = 2;
pub type ScConnectStatus = ::std::os::raw::c_uint;
#[doc = "!< Enter the active mode."]
pub const ScWorkMode_SC_ACTIVE_MODE: ScWorkMode = 0;
#[doc = "!< Enter the hardware salve mode, at this time need to connect\n!< the hardware trigger wire, provide hardware signal, to trigger the image."]
pub const ScWorkMode_SC_HARDWARE_TRIGGER_MODE: ScWorkMode = 1;
#[doc = "!< Enter the software salve mode, at this time need to invoke scSoftwareTriggerOnce, to trigger the image."]
pub const ScWorkMode_SC_SOFTWARE_TRIGGER_MODE: ScWorkMode = 2;
pub type ScWorkMode = ::std::os::raw::c_uint;
#[doc = "!< Enter the auto exposure mode."]
pub const ScExposureControlMode_SC_EXPOSURE_CONTROL_MODE_AUTO: ScExposureControlMode = 0;
#[doc = "!< Enter the manual exposure mode."]
pub const ScExposureControlMode_SC_EXPOSURE_CONTROL_MODE_MANUAL: ScExposureControlMode = 1;
pub type ScExposureControlMode = ::std::os::raw::c_uint;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type ScDepthPixel = u16;
#[doc = " @brief Stores the x, y, and z components of a 3D vector."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScVector3f {
    #[doc = "!< The x components of the vector."]
    pub x: f32,
    #[doc = "!< The y components of the vector."]
    pub y: f32,
    #[doc = "!< The z components of the vector."]
    pub z: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScVector3f"][::std::mem::size_of::<ScVector3f>() - 12usize];
    ["Alignment of ScVector3f"][::std::mem::align_of::<ScVector3f>() - 1usize];
    ["Offset of field: ScVector3f::x"][::std::mem::offset_of!(ScVector3f, x) - 0usize];
    ["Offset of field: ScVector3f::y"][::std::mem::offset_of!(ScVector3f, y) - 4usize];
    ["Offset of field: ScVector3f::z"][::std::mem::offset_of!(ScVector3f, z) - 8usize];
};
#[doc = " @brief Stores the x and y components of a 2D vector."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScVector2u16 {
    #[doc = "!< The x components of the vector."]
    pub x: u16,
    #[doc = "!< The y components of the vector."]
    pub y: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScVector2u16"][::std::mem::size_of::<ScVector2u16>() - 4usize];
    ["Alignment of ScVector2u16"][::std::mem::align_of::<ScVector2u16>() - 1usize];
    ["Offset of field: ScVector2u16::x"][::std::mem::offset_of!(ScVector2u16, x) - 0usize];
    ["Offset of field: ScVector2u16::y"][::std::mem::offset_of!(ScVector2u16, y) - 2usize];
};
#[doc = " @brief Contains depth information for a given pixel."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScDepthVector3 {
    #[doc = "!< The x coordinate of the pixel."]
    pub depthX: i32,
    #[doc = "!< The y coordinate of the pixel."]
    pub depthY: i32,
    #[doc = "!< The depth of the pixel, in millimeters."]
    pub depthZ: ScDepthPixel,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScDepthVector3"][::std::mem::size_of::<ScDepthVector3>() - 10usize];
    ["Alignment of ScDepthVector3"][::std::mem::align_of::<ScDepthVector3>() - 1usize];
    ["Offset of field: ScDepthVector3::depthX"]
        [::std::mem::offset_of!(ScDepthVector3, depthX) - 0usize];
    ["Offset of field: ScDepthVector3::depthY"]
        [::std::mem::offset_of!(ScDepthVector3, depthY) - 4usize];
    ["Offset of field: ScDepthVector3::depthZ"]
        [::std::mem::offset_of!(ScDepthVector3, depthZ) - 8usize];
};
#[doc = " @brief image resolution."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScResolution {
    pub width: i32,
    pub height: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScResolution"][::std::mem::size_of::<ScResolution>() - 8usize];
    ["Alignment of ScResolution"][::std::mem::align_of::<ScResolution>() - 1usize];
    ["Offset of field: ScResolution::width"][::std::mem::offset_of!(ScResolution, width) - 0usize];
    ["Offset of field: ScResolution::height"]
        [::std::mem::offset_of!(ScResolution, height) - 4usize];
};
#[doc = " @brief Supported resolutions."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScResolutionList {
    pub count: i32,
    pub resolution: [ScResolution; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScResolutionList"][::std::mem::size_of::<ScResolutionList>() - 52usize];
    ["Alignment of ScResolutionList"][::std::mem::align_of::<ScResolutionList>() - 1usize];
    ["Offset of field: ScResolutionList::count"]
        [::std::mem::offset_of!(ScResolutionList, count) - 0usize];
    ["Offset of field: ScResolutionList::resolution"]
        [::std::mem::offset_of!(ScResolutionList, resolution) - 4usize];
};
#[doc = " @brief Camera intrinsic parameters and distortion coefficients."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScSensorIntrinsicParameters {
    #[doc = "!< Focal length x (pixel)."]
    pub fx: f64,
    #[doc = "!< Focal length y (pixel)."]
    pub fy: f64,
    #[doc = "!< Principal point x (pixel)."]
    pub cx: f64,
    #[doc = "!< Principal point y (pixel)."]
    pub cy: f64,
    #[doc = "!< Radial distortion coefficient, 1st-order."]
    pub k1: f64,
    #[doc = "!< Radial distortion coefficient, 2nd-order."]
    pub k2: f64,
    #[doc = "!< Tangential distortion coefficient."]
    pub p1: f64,
    #[doc = "!< Tangential distortion coefficient."]
    pub p2: f64,
    #[doc = "!< Radial distortion coefficient, 3rd-order."]
    pub k3: f64,
    #[doc = "!< Radial distortion coefficient, 4st-order."]
    pub k4: f64,
    #[doc = "!< Radial distortion coefficient, 5nd-order."]
    pub k5: f64,
    #[doc = "!< Radial distortion coefficient, 6rd-order."]
    pub k6: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScSensorIntrinsicParameters"]
        [::std::mem::size_of::<ScSensorIntrinsicParameters>() - 96usize];
    ["Alignment of ScSensorIntrinsicParameters"]
        [::std::mem::align_of::<ScSensorIntrinsicParameters>() - 1usize];
    ["Offset of field: ScSensorIntrinsicParameters::fx"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, fx) - 0usize];
    ["Offset of field: ScSensorIntrinsicParameters::fy"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, fy) - 8usize];
    ["Offset of field: ScSensorIntrinsicParameters::cx"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, cx) - 16usize];
    ["Offset of field: ScSensorIntrinsicParameters::cy"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, cy) - 24usize];
    ["Offset of field: ScSensorIntrinsicParameters::k1"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, k1) - 32usize];
    ["Offset of field: ScSensorIntrinsicParameters::k2"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, k2) - 40usize];
    ["Offset of field: ScSensorIntrinsicParameters::p1"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, p1) - 48usize];
    ["Offset of field: ScSensorIntrinsicParameters::p2"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, p2) - 56usize];
    ["Offset of field: ScSensorIntrinsicParameters::k3"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, k3) - 64usize];
    ["Offset of field: ScSensorIntrinsicParameters::k4"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, k4) - 72usize];
    ["Offset of field: ScSensorIntrinsicParameters::k5"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, k5) - 80usize];
    ["Offset of field: ScSensorIntrinsicParameters::k6"]
        [::std::mem::offset_of!(ScSensorIntrinsicParameters, k6) - 88usize];
};
#[doc = " @brief Extrinsic parameters defines the physical relationship form tof sensor to color sensor."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScSensorExtrinsicParameters {
    #[doc = "!< Orientation stored as an array of 9 double representing a 3x3 rotation matrix."]
    pub rotation: [f64; 9usize],
    #[doc = "!< Location stored as an array of 3 double representing a 3-D translation vector."]
    pub translation: [f64; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScSensorExtrinsicParameters"]
        [::std::mem::size_of::<ScSensorExtrinsicParameters>() - 96usize];
    ["Alignment of ScSensorExtrinsicParameters"]
        [::std::mem::align_of::<ScSensorExtrinsicParameters>() - 1usize];
    ["Offset of field: ScSensorExtrinsicParameters::rotation"]
        [::std::mem::offset_of!(ScSensorExtrinsicParameters, rotation) - 0usize];
    ["Offset of field: ScSensorExtrinsicParameters::translation"]
        [::std::mem::offset_of!(ScSensorExtrinsicParameters, translation) - 72usize];
};
#[doc = " @brief Depth/IR/Color image frame data."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ScFrame {
    #[doc = "!< The index of the frame."]
    pub frameIndex: u32,
    #[doc = "!< The type of frame. See ::ScFrameType for more information."]
    pub frameType: ScFrameType,
    #[doc = "!< The pixel format used by a frame. See ::ScPixelFormat for more information."]
    pub pixelFormat: ScPixelFormat,
    #[doc = "!< A buffer containing the frameâ€™s image data."]
    pub pFrameData: *mut u8,
    #[doc = "!< The length of pFrame, in bytes."]
    pub dataLen: u32,
    #[doc = "!< The width of the frame, in pixels."]
    pub width: u16,
    #[doc = "!< The height of the frame, in pixels."]
    pub height: u16,
    #[doc = "!< The timestamp(in milliseconds) when the frame be generated on the device. Frame processing and transfer time are not included."]
    pub deviceTimestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScFrame"][::std::mem::size_of::<ScFrame>() - 36usize];
    ["Alignment of ScFrame"][::std::mem::align_of::<ScFrame>() - 1usize];
    ["Offset of field: ScFrame::frameIndex"][::std::mem::offset_of!(ScFrame, frameIndex) - 0usize];
    ["Offset of field: ScFrame::frameType"][::std::mem::offset_of!(ScFrame, frameType) - 4usize];
    ["Offset of field: ScFrame::pixelFormat"]
        [::std::mem::offset_of!(ScFrame, pixelFormat) - 8usize];
    ["Offset of field: ScFrame::pFrameData"][::std::mem::offset_of!(ScFrame, pFrameData) - 12usize];
    ["Offset of field: ScFrame::dataLen"][::std::mem::offset_of!(ScFrame, dataLen) - 20usize];
    ["Offset of field: ScFrame::width"][::std::mem::offset_of!(ScFrame, width) - 24usize];
    ["Offset of field: ScFrame::height"][::std::mem::offset_of!(ScFrame, height) - 26usize];
    ["Offset of field: ScFrame::deviceTimestamp"]
        [::std::mem::offset_of!(ScFrame, deviceTimestamp) - 28usize];
};
impl Default for ScFrame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScFrameReady {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScFrameReady"][::std::mem::size_of::<ScFrameReady>() - 4usize];
    ["Alignment of ScFrameReady"][::std::mem::align_of::<ScFrameReady>() - 1usize];
};
impl ScFrameReady {
    #[inline]
    pub fn depth(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_depth(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transformedColor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transformedColor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transformedDepth(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transformedDepth(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        depth: u32,
        ir: u32,
        color: u32,
        transformedColor: u32,
        transformedDepth: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let depth: u32 = unsafe { ::std::mem::transmute(depth) };
            depth as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ir: u32 = unsafe { ::std::mem::transmute(ir) };
            ir as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let color: u32 = unsafe { ::std::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let transformedColor: u32 = unsafe { ::std::mem::transmute(transformedColor) };
            transformedColor as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let transformedDepth: u32 = unsafe { ::std::mem::transmute(transformedDepth) };
            transformedDepth as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ScDeviceHandle = *mut ::std::os::raw::c_void;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ScDeviceInfo {
    #[doc = "!< Product type name."]
    pub productName: [::std::os::raw::c_char; 64usize],
    #[doc = "!< Device serial number."]
    pub serialNumber: [::std::os::raw::c_char; 64usize],
    #[doc = "!< Device IP."]
    pub ip: [::std::os::raw::c_char; 17usize],
    #[doc = "!< Device status."]
    pub status: ScConnectStatus,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScDeviceInfo"][::std::mem::size_of::<ScDeviceInfo>() - 149usize];
    ["Alignment of ScDeviceInfo"][::std::mem::align_of::<ScDeviceInfo>() - 1usize];
    ["Offset of field: ScDeviceInfo::productName"]
        [::std::mem::offset_of!(ScDeviceInfo, productName) - 0usize];
    ["Offset of field: ScDeviceInfo::serialNumber"]
        [::std::mem::offset_of!(ScDeviceInfo, serialNumber) - 64usize];
    ["Offset of field: ScDeviceInfo::ip"][::std::mem::offset_of!(ScDeviceInfo, ip) - 128usize];
    ["Offset of field: ScDeviceInfo::status"]
        [::std::mem::offset_of!(ScDeviceInfo, status) - 145usize];
};
impl Default for ScDeviceInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScTimeFilterParams {
    #[doc = "!< Range in [1, 6],The larger the value is, the more obvious the filtering effect is and The smaller the point cloud wobble."]
    pub threshold: i32,
    #[doc = "!< Whether to enable time filter."]
    pub enable: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScTimeFilterParams"][::std::mem::size_of::<ScTimeFilterParams>() - 5usize];
    ["Alignment of ScTimeFilterParams"][::std::mem::align_of::<ScTimeFilterParams>() - 1usize];
    ["Offset of field: ScTimeFilterParams::threshold"]
        [::std::mem::offset_of!(ScTimeFilterParams, threshold) - 0usize];
    ["Offset of field: ScTimeFilterParams::enable"]
        [::std::mem::offset_of!(ScTimeFilterParams, enable) - 4usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScConfidenceFilterParams {
    #[doc = "!< Range in [1, 100]. The larger the value is, the more obvious the filtering effect is and the more points are filtered out."]
    pub threshold: i32,
    #[doc = "!< Whether to enable confidence filter."]
    pub enable: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScConfidenceFilterParams"]
        [::std::mem::size_of::<ScConfidenceFilterParams>() - 5usize];
    ["Alignment of ScConfidenceFilterParams"]
        [::std::mem::align_of::<ScConfidenceFilterParams>() - 1usize];
    ["Offset of field: ScConfidenceFilterParams::threshold"]
        [::std::mem::offset_of!(ScConfidenceFilterParams, threshold) - 0usize];
    ["Offset of field: ScConfidenceFilterParams::enable"]
        [::std::mem::offset_of!(ScConfidenceFilterParams, enable) - 4usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScFlyingPixelFilterParams {
    #[doc = "!< Range in [1, 16]. The larger the value is, the more obvious the filtering effect is and the more points are filtered out."]
    pub threshold: i32,
    #[doc = "!< Whether to enable flying pixel filter."]
    pub enable: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScFlyingPixelFilterParams"]
        [::std::mem::size_of::<ScFlyingPixelFilterParams>() - 5usize];
    ["Alignment of ScFlyingPixelFilterParams"]
        [::std::mem::align_of::<ScFlyingPixelFilterParams>() - 1usize];
    ["Offset of field: ScFlyingPixelFilterParams::threshold"]
        [::std::mem::offset_of!(ScFlyingPixelFilterParams, threshold) - 0usize];
    ["Offset of field: ScFlyingPixelFilterParams::enable"]
        [::std::mem::offset_of!(ScFlyingPixelFilterParams, enable) - 4usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScIRGMMCorrectionParams {
    #[doc = "!< Range in [1, 100]. The larger the value is, the more obvious the correction effect."]
    pub threshold: i32,
    #[doc = "!< Whether to enable IRGMM correction."]
    pub enable: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScIRGMMCorrectionParams"][::std::mem::size_of::<ScIRGMMCorrectionParams>() - 5usize];
    ["Alignment of ScIRGMMCorrectionParams"]
        [::std::mem::align_of::<ScIRGMMCorrectionParams>() - 1usize];
    ["Offset of field: ScIRGMMCorrectionParams::threshold"]
        [::std::mem::offset_of!(ScIRGMMCorrectionParams, threshold) - 0usize];
    ["Offset of field: ScIRGMMCorrectionParams::enable"]
        [::std::mem::offset_of!(ScIRGMMCorrectionParams, enable) - 4usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScInputSignalParamsForHWTrigger {
    #[doc = "!< Range in [1,65535]. The width of input signal."]
    pub width: u16,
    #[doc = "!< Range in [34000,65535]. The interval of input signal."]
    pub interval: u16,
    #[doc = "!< Range in [0,1]. 0 for active low; 1 for active high."]
    pub polarity: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScInputSignalParamsForHWTrigger"]
        [::std::mem::size_of::<ScInputSignalParamsForHWTrigger>() - 5usize];
    ["Alignment of ScInputSignalParamsForHWTrigger"]
        [::std::mem::align_of::<ScInputSignalParamsForHWTrigger>() - 1usize];
    ["Offset of field: ScInputSignalParamsForHWTrigger::width"]
        [::std::mem::offset_of!(ScInputSignalParamsForHWTrigger, width) - 0usize];
    ["Offset of field: ScInputSignalParamsForHWTrigger::interval"]
        [::std::mem::offset_of!(ScInputSignalParamsForHWTrigger, interval) - 2usize];
    ["Offset of field: ScInputSignalParamsForHWTrigger::polarity"]
        [::std::mem::offset_of!(ScInputSignalParamsForHWTrigger, polarity) - 4usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScOutputSignalParams {
    #[doc = "!< Range in [1,65535]. The width of output signal."]
    pub width: u16,
    #[doc = "!< Range in [0,65535]. The delay time of output signal."]
    pub delay: u16,
    #[doc = "!< Range in [0,1]. 0 for active low; 1 for active high."]
    pub polarity: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScOutputSignalParams"][::std::mem::size_of::<ScOutputSignalParams>() - 5usize];
    ["Alignment of ScOutputSignalParams"][::std::mem::align_of::<ScOutputSignalParams>() - 1usize];
    ["Offset of field: ScOutputSignalParams::width"]
        [::std::mem::offset_of!(ScOutputSignalParams, width) - 0usize];
    ["Offset of field: ScOutputSignalParams::delay"]
        [::std::mem::offset_of!(ScOutputSignalParams, delay) - 2usize];
    ["Offset of field: ScOutputSignalParams::polarity"]
        [::std::mem::offset_of!(ScOutputSignalParams, polarity) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScTimeSyncConfig {
    #[doc = "!< 0: disable, 1: NTP, 2: PTP, only NTP needs the ip."]
    pub flag: u8,
    #[doc = "!< just for NTP."]
    pub ip: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ScTimeSyncConfig"][::std::mem::size_of::<ScTimeSyncConfig>() - 17usize];
    ["Alignment of ScTimeSyncConfig"][::std::mem::align_of::<ScTimeSyncConfig>() - 1usize];
    ["Offset of field: ScTimeSyncConfig::flag"]
        [::std::mem::offset_of!(ScTimeSyncConfig, flag) - 0usize];
    ["Offset of field: ScTimeSyncConfig::ip"]
        [::std::mem::offset_of!(ScTimeSyncConfig, ip) - 1usize];
};
#[doc = " @brief         Hot plug status callback function.\n @param[out]    pInfo     Return the info of the Device, See ::ScDeviceInfo.\n @param[out]    state     Hot plug status. 0:device added , 1:device removed.\n @param[out]    pUserData Pointer to user data, which can be null."]
pub type PtrHotPlugStatusCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pInfo: *const ScDeviceInfo,
        state: ::std::os::raw::c_int,
        pUserData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief         Upgrade status callback function.\n @param[out]    status     Returns the upgrade step status.\n @param[out]    params     Params of upgrade step status , -1:upgrade fail , 0:upgrade Normal, 1-100:upgrade progress.\n @param[out]    pUserData  Pointer to user data, which can be null."]
pub type PtrUpgradeStatusCallback = ::std::option::Option<
    unsafe extern "C" fn(
        status: ::std::os::raw::c_int,
        params: ::std::os::raw::c_int,
        pUserData: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief        Initializes the API on the device. This function must be invoked before any other Scepter APIs.\n @return       ::SC_OK    If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scInitialize() -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Shuts down the API on the device and clears all resources allocated by the API. After\n               invoking this function, no other Scepter APIs can be invoked.\n @return       ::SC_OK    If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scShutdown() -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the version of SDK.\n @return       Returns sdk version."]
    pub fn scGetSDKVersion(pSDKVersion: *mut ::std::os::raw::c_char, length: i32) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the number of camera devices currently connected.\n @param[out]   pDeviceCount    Pointer to a 32-bit integer variable in which to return the device count.\n @param[in]    scanTime        Scans time, the unit is millisecond.\nThis function scans devices for scanTime(ms) and then returns the count of devices.\n @return       ::SC_OK         If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetDeviceCount(pDeviceCount: *mut u32, scanTime: u32) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the info lists of the deviceCount camera devices.\n @param[in]    deviceCount         The number of camera devices.\n @param[out]   pDevicesInfoList    Pointer to a buffer in which to store the devices list infos.\n @return       ::SC_OK             If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetDeviceInfoList(deviceCount: u32, pDevicesInfoList: *mut ScDeviceInfo) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Opens the device specified by <code>serialNumber</code>. The device must be subsequently closed using scCloseDevice().\n @param[in]    pSN         The uri of the device. See ::ScDeviceInfo for more information.\n @param[out]   pDevice      The handle of the device on which to open.\n @return:      ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scOpenDeviceBySN(
        pSN: *const ::std::os::raw::c_char,
        pDevice: *mut ScDeviceHandle,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Opens the device specified by <code>ip</code>. The device must be subsequently closed using scCloseDevice().\n @param[in]    pIP          The ip of the device. See ::ScDeviceInfo for more information.\n @param[out]   pDevice      The handle of the device on which to open.\n @return:      ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scOpenDeviceByIP(
        pIP: *const ::std::os::raw::c_char,
        pDevice: *mut ScDeviceHandle,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Closes the device specified by <code>device</code> that was opened using scOpenDevice.\n @param[in]    pDevice       The handle of the device to close.\n @return:      ::SC_OK       If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scCloseDevice(pDevice: *mut ScDeviceHandle) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Starts capturing the image stream indicated by <code>device</code>. Invoke scStopStream() to stop capturing the image stream.\n @param[in]    device          The handle of the device on which to start capturing the image stream.\n @return       ::SC_OK         If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scStartStream(device: ScDeviceHandle) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Stops capturing the image stream on the device specified by <code>device</code>. that was started using scStartStream.\n @param[in]    device       The handle of the device on which to stop capturing the image stream.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scStopStream(device: ScDeviceHandle) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Captures the next image frame from the device specified by <code>device</code>. This API must be invoked before capturing frame data using scGetFrame().\n @param[in]    device         The handle of the device on which to read the next frame.\n @param[in]    waitTime       The unit is millisecond, the value is in the range (0,65535).\n                              You can change the value according to the frame rate. For example,the frame rate is 30, so the theoretical waittime interval is 33ms,\n                              but if set the time value is 20ms, it means the maximum wait time is 20 ms when capturing next frame, so when call the scGetFrameReady,\n                              it may return SC_GET_FRAME_READY_TIME_OUT(-11).\n                              So the recommended value is 2 * 1000/ FPS.\n @param[out]   pFrameReady    Pointer to a buffer in which to store the signal on which image is ready to be get.\n @return       ::SC_OK        If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetFrameReady(
        device: ScDeviceHandle,
        waitTime: u16,
        pFrameReady: *mut ScFrameReady,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the image data for the current frame from the device specified by <code>device</code>.\n               Before invoking this API, invoke scGetFrameReady() to capture one image frame from the device.\n @param[in]    device       The handle of the device to capture an image frame from.\n @param[in]    frameType    The image frame type.\n @param[out]   pScFrame     Pointer to a buffer in which to store the returned image data.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetFrame(
        device: ScDeviceHandle,
        frameType: ScFrameType,
        pScFrame: *mut ScFrame,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the depth range in the current working mode of the device.\n @param[in]    device       The handle of the device.\n @param[out]   minValue     The min value of the depth\n @param[out]   maxValue     The ax value of the depth\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetDepthRangeValue(
        device: ScDeviceHandle,
        minValue: *mut i16,
        maxValue: *mut i16,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the internal intrinsic and distortion coefficient parameters from the device specified by <code>device</code>.\n @param[in]    device                        The handle of the device from which to get the internal parameters.\n @param[in]    sensorType                    The type of sensor (depth or color) from which to get parameter information. Pass in the applicable value defined by ::ScSensorType.\n @param[out]   pSensorIntrinsicParameters    Pointer to a ScSensorIntrinsicParameters variable in which to store the parameter values.\n @return       ::SC_OK                       If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetSensorIntrinsicParameters(
        device: ScDeviceHandle,
        sensorType: ScSensorType,
        pSensorIntrinsicParameters: *mut ScSensorIntrinsicParameters,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the camera rotation and translation coefficient parameters from the device specified by <code>device</code>.\n @param[in]    device                        The handle of the device from which to get the extrinsic parameters.\n @param[out]   pSensorExtrinsicParameters    Pointer to a ::ScSensorExtrinsicParameters variable in which to store the parameters.\n @return       ::SC_OK                       If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetSensorExtrinsicParameters(
        device: ScDeviceHandle,
        pSensorExtrinsicParameters: *mut ScSensorExtrinsicParameters,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the firmware version number.\n @param[in]    device              The handle of the device on which to set the pulse count.\n @param[out]   pFirmwareVersion    Pointer to a variable in which to store the returned fw value.\n @param[in]    length              The maximum length is 64 bytes.\n @return       ::SC_OK             If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetFirmwareVersion(
        device: ScDeviceHandle,
        pFirmwareVersion: *mut ::std::os::raw::c_char,
        length: i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the MAC from the device specified by <code>device</code>.\n @param[in]    device         The handle of the device.\n @param[out]   pMACAddress    Pointer to a buffer in which to store the device MAC address. the buffer default size is 18, and the last buffer set '\\0'.\n @return       ::SC_OK        If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetDeviceMACAddress(
        device: ScDeviceHandle,
        pMACAddress: *mut ::std::os::raw::c_char,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Enables or disables DHCP. Default disabled\n @param[in]    device       The handle of the device on which to enable or disable the feature.\n @param[in]    bEnabled     Set to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetDeviceDHCPEnabled(device: ScDeviceHandle, bEnabled: u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the Boolean value of whether the device is in DHCP or not.\n @param[in]    device       The handle of the device on which to enable or disable the feature.\n @param[out]   bEnabled     Set to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetDeviceDHCPEnabled(device: ScDeviceHandle, bEnabled: *mut u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the IP address of the device in non-DHCP mode. The call takes effect after the device is restarted.\n @param[in]    device         The handle of the device.\n @param[in]    ipAddr         Pointer to a buffer in which to store the device IP address. the buffer default size is 16, and the last buffer set '\\0'.\n @param[in]    length         The length of the buffer.\n @return       ::SC_OK        If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetDeviceIPAddr(
        device: ScDeviceHandle,
        ipAddr: *const ::std::os::raw::c_char,
        length: i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the IP address of the device in non-DHCP mode.\n @param[in]    device         The handle of the device.\n @param[out]   ipAddr         Pointer to a buffer in which to store the device IP address. the buffer default size is 16, and the last buffer set '\\0'.\n @return       ::SC_OK        If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetDeviceIPAddr(
        device: ScDeviceHandle,
        ipAddr: *mut ::std::os::raw::c_char,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the subnet mask of the device in non-DHCP mode. The call takes effect after the device is restarted.\n @param[in]    device         The handle of the device.\n @param[in]    pMask          Pointer to a buffer in which to store the subnet mask address. the buffer default size is 16, and the last buffer set '\\0'.\n @param[in]    length         The length of the buffer.\n @return       ::SC_OK        If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetDeviceSubnetMask(
        device: ScDeviceHandle,
        pMask: *const ::std::os::raw::c_char,
        length: i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the subnet mask of the device in non-DHCP mode.\n @param[in]    device         The handle of the device.\n @param[out]   pMask          Pointer to a buffer in which to store the device subnet mask address. the buffer default size is 16, and the last buffer set '\\0'.\n @return       ::SC_OK        If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetDeviceSubnetMask(
        device: ScDeviceHandle,
        pMask: *mut ::std::os::raw::c_char,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the parameters for time sync, such as enable the NTP/PTP\n @param[in]    device       The handle of the device on which to enable or disable the feature.\n @param[in]    params       The parameters defined by ::ScTimeSyncConfig.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetRealTimeSyncConfig(device: ScDeviceHandle, params: ScTimeSyncConfig) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the parameters for time sync,such as the status of the NTP/PTP\n @param[in]    device       The handle of the device on which to enable or disable the feature.\n @param[out]   pParams      Pointer to a variable in which to store the returned value.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetRealTimeSyncConfig(
        device: ScDeviceHandle,
        pParams: *mut ScTimeSyncConfig,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the ToF frame rate.The interface takes a long time, about 500 ms.\n @param[in]    device       The handle of the device on which to set the framerate.\n @param[in]    value        The rate value. Different products have different maximum values. Please refer to the product specification.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetFrameRate(device: ScDeviceHandle, value: i32) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the ToF frame rate.\n @param[in]    device       The handle of the device on which to get the framerate.\n @param[out]   pValue       The rate value.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetFrameRate(device: ScDeviceHandle, pValue: *mut i32) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the working mode of the camera.\n @param[in]    device      The handle of the device.\n @param[in]    mode        The work mode of camera. For ActiveMode, set the Time filter default true, for SlaveMode, set the Time filter default false.\n @return       ::SC_OK     If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetWorkMode(device: ScDeviceHandle, mode: ScWorkMode) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the working mode of the camera.\n @param[in]    device      The handle of the device.\n @param[out]   pMode       The work mode of camera.\n @return       ::SC_OK     If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetWorkMode(device: ScDeviceHandle, pMode: *mut ScWorkMode) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the count of frame in SC_SOFTWARE_TRIGGER_MODE.\n\t\t\t\t The more frames there are, the better frame's quality after algorithm processing\n @param[in]    device       The handle of the device on which to set the parameter\n @param[in]    frameCount\t  The count of frame, in range [1,10].\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetSoftwareTriggerParameter(device: ScDeviceHandle, frameCount: u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the count of framer in SC_SOFTWARE_TRIGGER_MODE.\n @param[in]    device       The handle of the device from which to get the parameter\n @param[out]   pframeCount  Pointer to a variable in which to store the count of frame, in range [1,10].\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetSoftwareTriggerParameter(device: ScDeviceHandle, pframeCount: *mut u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get a frame in SC_SOFTWARE_TRIGGER_MODE.\n               Call the scSetSoftwareTriggerParameter API to improve the quality of depth frame.\n @param[in]    device      The handle of the device.\n @return       ::SC_OK     If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSoftwareTriggerOnce(device: ScDeviceHandle) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the input signal parameters for Hardware Trigger.\n @param[in]    device       The handle of the device\n @param[in]    params       Pointer to a variable in which to store the parameters.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetInputSignalParamsForHWTrigger(
        device: ScDeviceHandle,
        params: ScInputSignalParamsForHWTrigger,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the Input signal parameters for Hardware Trigger.\n @param[in]    device       The handle of the device\n @param[out]   pParams      Pointer to a variable in which to store the returned value.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetInputSignalParamsForHWTrigger(
        device: ScDeviceHandle,
        pParams: *mut ScInputSignalParamsForHWTrigger,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the device GMM gain on a device.\n @param[in]    device       The handle of the device on which to set the GMM gain.\n @param[in]    gmmgain      The value of IRGMM Gain. Different products have different maximum value. Please refer to the product specification.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetIRGMMGain(device: ScDeviceHandle, gmmgain: u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the the device's GMM gain.\n @param[in]    device       The handle of the device from which to get the GMM gain.\n @param[out]   pGmmgain     Pointer to a variable in which to store the returned GMM gain.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetIRGMMGain(device: ScDeviceHandle, pGmmgain: *mut u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the device IR GMM Correction on a device.\n @param[in]    device       The handle of the device.\n @param[in]    params       The value of IR GMM Correction.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetIRGMMCorrection(
        device: ScDeviceHandle,
        params: ScIRGMMCorrectionParams,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Return the device IR GMM Correction on a device.\n @param[in]    device       The handle of the device.\n @param[out]   params       The value of IR GMM Correction.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetIRGMMCorrection(
        device: ScDeviceHandle,
        pParams: *mut ScIRGMMCorrectionParams,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the color image pixel format on the device specified by <code>device</code>. Currently only RGB and BGR formats are supported.\n @param[in]    device         The handle of the device to set the pixel format.\n @param[in]    pixelFormat    The color pixel format to use. Pass in one of the values defined by ::ScPixelFormat. Others cameras support only\n                              <code>SC_PIXEL_FORMAT_RGB_888_JPEG</code> and <code>SC_PIXEL_FORMAT_BGR_888_JPEG</code>.\n @return       ::SC_OK        If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetColorPixelFormat(device: ScDeviceHandle, pixelFormat: ScPixelFormat) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the color Gain with the exposure mode of Color sensor in SC_EXPOSURE_CONTROL_MODE_MANUAL.\n @param[in]    device       The handle of the device.\n @param[in]    params       The value of color Gain.Different products have different maximum value. Please refer to the product specification.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetColorGain(device: ScDeviceHandle, params: f32) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the color Gain.\n @param[in]    device       The handle of the device.\n @param[out]   params       The value of color Gain.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetColorGain(device: ScDeviceHandle, pParams: *mut f32) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get a list of image resolutions supported by Sensor\n @param[in]    device       The handle of the device.\n @param[in]    type         The sensor type\n @param[out]   pList        List of supported resolutions\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetSupportedResolutionList(
        device: ScDeviceHandle,
        type_: ScSensorType,
        pList: *mut ScResolutionList,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the color frame Resolution.\n @param[in]    device       The handle of the device.\n @param[in]    w            The width of color image\n @param[in]    h            The height of color image\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetColorResolution(device: ScDeviceHandle, w: i32, h: i32) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the the color frame Resolution.\n @param[in]    device       The handle of the device.\n @param[out]   pW           The width of color image\n @param[out]   pH           The height of color image\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetColorResolution(device: ScDeviceHandle, pW: *mut i32, pH: *mut i32) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the exposure mode of sensor.\n @param[in]    device          The handle of the device on which to set the exposure control mode.\n @param[in]    sensorType      The type of sensor (depth or color) from which to get parameter information. Pass in the applicable value defined by ::ScSensorType.\n @param[in]    exposureType    The exposure control mode.\n @return       ::SC_OK         If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetExposureControlMode(
        device: ScDeviceHandle,
        sensorType: ScSensorType,
        controlMode: ScExposureControlMode,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the exposure mode of sensor.\n @param[in]    device           The handle of the device on which to get the exposure control mode.\n @param[in]    sensorType       The type of sensor (depth or color) from which to get parameter information. Pass in the applicable value defined by ::ScSensorType.\n @param[out]   pControlMode     The exposure control mode.\n @return       ::SC_OK          If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetExposureControlMode(
        device: ScDeviceHandle,
        sensorType: ScSensorType,
        pControlMode: *mut ScExposureControlMode,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the exposure time of sensor.\n @param[in]    device          The handle of the device on which to set the exposure time  in microseconds.\n @param[in]    sensorType      The type of sensor (depth or color) from which to get parameter information. Pass in the applicable value defined by ::ScSensorType.\n @param[in]    exposureTime    The exposure time. The value must be within the maximum exposure time of sensor.\n @return       ::SC_OK         If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetExposureTime(
        device: ScDeviceHandle,
        sensorType: ScSensorType,
        exposureTime: i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the exposure time of sensor.\n @param[in]    device           The handle of the device on which to get the exposure time in microseconds.\n @param[in]    sensorType       The type of sensor (depth or color) from which to get parameter information. Pass in the applicable value defined by ::ScSensorType.\n @param[out]   pExposureTime    The exposure time.\n @return       ::SC_OK          If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetExposureTime(
        device: ScDeviceHandle,
        sensorType: ScSensorType,
        pExposureTime: *mut i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the maximum exposure time of color sensor in automatic mode. The interface is used in automatic mode.\n @param[in]    device          The handle of the device on which to set the exposure time in microseconds.\n @param[in]    exposureTime    The exposure time. The value must be within the maximum exposure time of sensor.\n @return       ::SC_OK         If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetColorAECMaxExposureTime(device: ScDeviceHandle, exposureTime: i32) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the maximum exposure time of color sensor in automatic mode. The interface is used in automatic mode.\n @param[in]    device           The handle of the device on which to get the exposure time in microseconds.\n @param[out]   pExposureTime    The exposure time.\n @return       ::SC_OK          If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetColorAECMaxExposureTime(
        device: ScDeviceHandle,
        pExposureTime: *mut i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the maximum exposure time of sensor.\n @param[in]    device           The handle of the device on which to get the exposure time in microseconds.\n @param[in]    sensorType       The type of sensor (depth or color) from which to get parameter information. Pass in the applicable value defined by ::ScSensorType.\n @param[out]   pMaxExposureTime The maximum exposure time. The maximum exposure time is different at different frame rates.\n @return       ::SC_OK          If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetMaxExposureTime(
        device: ScDeviceHandle,
        sensorType: ScSensorType,
        pMaxExposureTime: *mut i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Enables or disables the HDR Mode of the ToF sensor with SC_EXPOSURE_CONTROL_MODE_MANUAL. Default enabled,\n               so if you want switch to the SC_EXPOSURE_CONTROL_MODE_AUTO, set HDR Mode disable firstly.\n @param[in]    device       The handle of the device on which to enable or disable the feature.\n @param[in]    bEnabled     Set to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetHDRModeEnabled(device: ScDeviceHandle, bEnabled: u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the Boolean value of whether the HDR Mode of ToF sensor feature is enabled or disabled.\n @param[in]    device       The handle of the device on which to enable or disable the feature.\n @param[out]   bEnabled     Set to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetHDRModeEnabled(device: ScDeviceHandle, bEnabled: *mut u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the count of frame in HDR mode.\n @param[in]    device           The handle of the device on which to get the exposure time in microseconds.\n @param[out]   pCount           The frame count.\n @return       ::SC_OK          If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetFrameCountOfHDRMode(device: ScDeviceHandle, pCount: *mut i32) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the exposure time of depth sensor with the frameIndex in HDR mode.\n @param[in]    device          The handle of the device on which to set the exposure time  in microseconds.\n @param[in]    frameIndex      The frameIndex from 0 to the count (get by scGetFrameCountOfHDRMode).\n @param[in]    exposureTime    The exposure time. The value must be within the maximum exposure time of sensor.\n @return       ::SC_OK         If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetExposureTimeOfHDR(
        device: ScDeviceHandle,
        frameIndex: u8,
        exposureTime: i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the exposure time of depth sensor with the frameIndex in HDR mode.\n @param[in]    device           The handle of the device on which to get the exposure time in microseconds.\n @param[in]    frameIndex       The frameIndex from 0 to the count (get by scGetFrameCountOfHDRMode).\n @param[out]   pExposureTime    The exposure time.\n @return       ::SC_OK          If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetExposureTimeOfHDR(
        device: ScDeviceHandle,
        frameIndex: u8,
        pExposureTime: *mut i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the maximum exposure time of depth sensor with the frameIndex in HDR mode.\n @param[in]    device           The handle of the device on which to get the exposure time in microseconds.\n @param[in]    frameIndex       The frameIndex from 0 to the count (get by scGetFrameCountOfHDRMode).\n @param[out]   pMaxExposureTime The maximum exposure time. The maximum exposure time is different at different frame rates.\n @return       ::SC_OK          If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetMaxExposureTimeOfHDR(
        device: ScDeviceHandle,
        frameIndex: u8,
        pMaxExposureTime: *mut i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Enables or disables the WDR Mode of the ToF sensor. Default enabled\n @param[in]    device       The handle of the device on which to enable or disable the feature.\n @param[in]    bEnabled     Set to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetWDRModeEnabled(device: ScDeviceHandle, bEnabled: u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the Boolean value of whether the WDRMode of ToF sensor feature is enabled or disabled.\n @param[in]    device       The handle of the device on which to enable or disable the feature.\n @param[out]   bEnabled     Set to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetWDRModeEnabled(device: ScDeviceHandle, bEnabled: *mut u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the count of frame in WDR mode.\n @param[in]    device           The handle of the device on which to get the exposure time in microseconds.\n @param[out]   pCount           The frame count.\n @return       ::SC_OK          If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetFrameCountOfWDRMode(device: ScDeviceHandle, pCount: *mut i32) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the exposure time of depth sensor with the frameIndex in WDR mode.\n @param[in]    device          The handle of the device on which to set the exposure time  in microseconds.\n @param[in]    frameIndex      The frameIndex from 0 to the count (get by scGetFrameCountOfWDRMode).\n @param[in]    exposureTime    The exposure time. The value must be within the maximum exposure time of sensor.\n @return       ::SC_OK         If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetExposureTimeOfWDR(
        device: ScDeviceHandle,
        frameIndex: u8,
        exposureTime: i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the exposure time of depth sensor with the frameIndex in WDR mode.\n @param[in]    device           The handle of the device on which to get the exposure time in microseconds.\n @param[in]    frameIndex       The frameIndex from 0 to the count (get by scGetFrameCountOfWDRMode).\n @param[out]   pExposureTime    The exposure time.\n @return       ::SC_OK          If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetExposureTimeOfWDR(
        device: ScDeviceHandle,
        frameIndex: u8,
        pExposureTime: *mut i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the maximum exposure time of depth sensor with the frameIndex in WDR mode.\n @param[in]    device           The handle of the device on which to get the exposure time in microseconds.\n @param[in]    frameIndex       The frameIndex from 0 to the count (get by scGetFrameCountOfWDRMode).\n @param[out]   pMaxExposureTime The maximum exposure time. The maximum exposure time is different at different frame rates.\n @return       ::SC_OK          If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetMaxExposureTimeOfWDR(
        device: ScDeviceHandle,
        frameIndex: u8,
        pMaxExposureTime: *mut i32,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the parameters of the Time filter.\n @param[in]    device       The handle of the device\n @param[in]    params       Pointer to a variable in which to store the parameters.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetTimeFilterParams(device: ScDeviceHandle, params: ScTimeFilterParams) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the parameters of the Time Filter feature.\n @param[in]    device       The handle of the device\n @param[out]   pParams      Pointer to a variable in which to store the returned value.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetTimeFilterParams(
        device: ScDeviceHandle,
        pParams: *mut ScTimeFilterParams,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the parameters of the Confidence filter.\n @param[in]    device       The handle of the device\n @param[in]    params       Pointer to a variable in which to store the parameters.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetConfidenceFilterParams(
        device: ScDeviceHandle,
        params: ScConfidenceFilterParams,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the parameters of the ConfidenceFilter feature.\n @param[in]    device       The handle of the device\n @param[out]   pParams      Pointer to a variable in which to store the returned value.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetConfidenceFilterParams(
        device: ScDeviceHandle,
        pParams: *mut ScConfidenceFilterParams,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the parameters of the FlyingPixel filter.\n @param[in]    device       The handle of the device.\n @param[in]    params       Pointer to a variable in which to store the parameters.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetFlyingPixelFilterParams(
        device: ScDeviceHandle,
        params: ScFlyingPixelFilterParams,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get the parameters of the FlyingPixel filter.\n @param[in]    device       The handle of the device\n @param[out]   pParams      Pointer to a variable in which to store the returned value.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetFlyingPixelFilterParams(
        device: ScDeviceHandle,
        params: *mut ScFlyingPixelFilterParams,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Enables or disables the FillHole filter\n @param[in]    device       The handle of the device.\n @param[in]    bEnabled     Set to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetFillHoleFilterEnabled(device: ScDeviceHandle, bEnabled: u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the Boolean value of whether the FillHole Filter feature is enabled or disabled.\n @param[in]    device       The handle of the device\n @param[out]   pEnabled     Pointer to a variable in which to store the returned Boolean value.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetFillHoleFilterEnabled(device: ScDeviceHandle, pEnabled: *mut u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Enables or disables the Spatial filter\n @param[in]    device       The handle of the device.\n @param[in]    bEnabled     Set to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetSpatialFilterEnabled(device: ScDeviceHandle, bEnabled: u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the Boolean value of whether the Spatial Filter feature is enabled or disabled.\n @param[in]    device       The handle of the device\n @param[out]   pEnabled     Pointer to a variable in which to store the returned Boolean value.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetSpatialFilterEnabled(device: ScDeviceHandle, pEnabled: *mut u8) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Enables or disables transforms a color image into the geometry of the depth sensor. When enabled, scGetFrame() can\\n\n               be invoked passing ::ScTransformedColorFrame as the frame type for get a color image which each pixel matches the \\n\n               corresponding pixel coordinates of the depth sensor. The resolution of the transformed color frame is the same as that\\n\n               of the depth image.\n @param[in]    device       The handle of the device on which to enable or disable mapping.\n @param[in]    bEnabled     Set to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetTransformColorImgToDepthSensorEnabled(
        device: ScDeviceHandle,
        bEnabled: u8,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the Boolean value of whether the transformed of the color image to depth sensor space feature is enabled or disabled.\n @param[in]    device       The handle of the device on which to enable or disable the feature.\n @param[out]   bEnabled     Pointer to a variable in which to store the returned Boolean value.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetTransformColorImgToDepthSensorEnabled(
        device: ScDeviceHandle,
        bEnabled: *mut u8,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Enables or disables transforms the depth map into the geometry of the color sensor. When enabled, scGetFrame() can\\n\n               be invoked passing ::ScTransformedDepthFrame as the frame type for get a depth image which each pixel matches the \\n\n               corresponding pixel coordinates of the color sensor. The resolution of the transformed depth frame is the same as that\\n\n               of the color image.\n @param[in]    device       The handle of the device on which to enable or disable mapping.\n @param[in]    bEnabled     Set to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetTransformDepthImgToColorSensorEnabled(
        device: ScDeviceHandle,
        bEnabled: u8,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the Boolean value of whether the transformed of the depth image to color space feature is enabled or disabled.\n @param[in]    device       The handle of the device on which to enable or disable the feature.\n @param[out]   bEnabled     Pointer to a variable in which to store the returned Boolean value.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetTransformDepthImgToColorSensorEnabled(
        device: ScDeviceHandle,
        bEnabled: *mut u8,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Returns the point value of the frame that the mapping of the depth image to Color space.\n @param[in]    device           The handle of the device on which to enable or disable the feature.\n @param[in]    depthPoint       The point in depth frame.\n @param[in]    colorSize        The size(x = w,y = h) of color frame.\n @param[out]   pPointInColor    The point in the color frame.\n @return       ::SC_OK          If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scTransformDepthPointToColorPoint(
        device: ScDeviceHandle,
        depthPoint: ScDepthVector3,
        colorSize: ScVector2u16,
        pPointInColor: *mut ScVector2u16,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Converts the input points from depth coordinate space to world coordinate space.\n @param[in]    device          The handle of the device on which to perform the operation.\n @param[in]    pDepthVector    Pointer to a buffer containing the x, y, and z values of the depth coordinates to be converted. \\n\n                               x and y are measured in pixels, where 0, 0 is located at the top left corner of the image. \\n\n                               z is measured in millimeters, based on the ::ScPixelFormat depth frame.\n @param[out]   pWorldVector    Pointer to a buffer in which to output the converted x, y, and z values of the world coordinates, measured in millimeters.\n @param[in]    pointCount      The number of points to convert.\n @param[in]    pSensorParam    The intrinsic parameters for the depth sensor. See ::ScSensorIntrinsicParameters.\n @return       ::SC_OK         If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scConvertDepthToPointCloud(
        device: ScDeviceHandle,
        pDepthVector: *mut ScDepthVector3,
        pWorldVector: *mut ScVector3f,
        pointCount: i32,
        pSensorParam: *mut ScSensorIntrinsicParameters,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Converts the input Depth frame from depth coordinate space to world coordinate space on the device. Currently supported depth\n               image types are SC_DEPTH_FRAME and SC_TRANSFORM_DEPTH_IMG_TO_COLOR_SENSOR_FRAME.\n @param[in]    device         The handle of the device on which to perform the operation.\n @param[in]    pDepthFrame    The depth frame.\n @param[out]   pWorldVector   Pointer to a buffer in which to output the converted x, y, and z values of the world coordinates,\n                              measured in millimeters. The length of pWorldVector must is (ScFrame.width * ScFrame.height).\n @return       ::SC_OK        If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scConvertDepthFrameToPointCloudVector(
        device: ScDeviceHandle,
        pDepthFrame: *const ScFrame,
        pWorldVector: *mut ScVector3f,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set the parameters by Json file that can be saved by ScepterGUITool.\n @param[in]    device       The handle of the device.\n @param[in]    pfilePath    Pointer to the path of Json file.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetParamsByJson(
        device: ScDeviceHandle,
        pfilePath: *mut ::std::os::raw::c_char,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Export the parameter initialization file from the device.\n @param[in]    device       The handle of the device.\n @param[in]    pfilePath    Pointer to the path of parameter initialization file.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scExportParamInitFile(
        device: ScDeviceHandle,
        pfilePath: *mut ::std::os::raw::c_char,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Import the parameter initialization file into the device and take effect after reboot the device.\n @param[in]    device       The handle of the device.\n @param[in]    pfilePath    Pointer to the path of parameter initialization file.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scImportParamInitFile(
        device: ScDeviceHandle,
        pfilePath: *mut ::std::os::raw::c_char,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Restore the parameter initialization file of the device.\n @param[in]    device       The handle of the device.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scRestoreParamInitFile(device: ScDeviceHandle) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Reboot the camera.\n @param[in]    device          The handle of the device\n @return       ::SC_OK         If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scRebootDevie(device: ScDeviceHandle) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Set hotplug status callback function.\n @param[in]    pCallback    Pointer to the callback function. See ::PtrHotPlugStatusCallback\n @param[in]    pUserData    Pointer to the user data. See ::PtrHotPlugStatusCallback\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scSetHotPlugStatusCallback(
        pCallback: PtrHotPlugStatusCallback,
        pUserData: *const ::std::os::raw::c_void,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Input the firmware file path and start upgrading device firmware.\n @param[in]    device       The handle of the device.\n @param[in]    pImgPath     Pointer to the path of firmware file. The firmware upgrade file is in .img format.\n @return       ::SC_OK      If the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scStartUpgradeFirmWare(
        device: ScDeviceHandle,
        pImgPath: *mut ::std::os::raw::c_char,
    ) -> ScStatus;
}
extern "C" {
    #[doc = " @brief        Get firmware upgrade status and progress.\n @param[in]    device       The handle of the device.\n @param[out]   pStatus      Pointer to the status of firmware upgrade. 0 indicates normal, other values indicate anomalies.\n @param[out]   pProcess     Pointer to the process of firmware upgrade, in range [0, 100]. Under normal circumstances, 100 indicates a successful upgrade.\n @return       ::SC_OK      if the function succeeded, or one of the error values defined by ::ScStatus."]
    pub fn scGetUpgradeStatus(
        device: ScDeviceHandle,
        pStatus: *mut i32,
        pProcess: *mut i32,
    ) -> ScStatus;
}
