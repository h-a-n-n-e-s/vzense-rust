/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const PsDepthRange_PsUnknown: PsDepthRange = -1;
pub const PsDepthRange_PsNearRange: PsDepthRange = 0;
pub const PsDepthRange_PsMidRange: PsDepthRange = 1;
pub const PsDepthRange_PsFarRange: PsDepthRange = 2;
pub const PsDepthRange_PsXNearRange: PsDepthRange = 3;
pub const PsDepthRange_PsXMidRange: PsDepthRange = 4;
pub const PsDepthRange_PsXFarRange: PsDepthRange = 5;
pub const PsDepthRange_PsXXNearRange: PsDepthRange = 6;
pub const PsDepthRange_PsXXMidRange: PsDepthRange = 7;
pub const PsDepthRange_PsXXFarRange: PsDepthRange = 8;
#[doc = " @brief Depth range setting.\\n\n        These set estimated ranges. Detection distances may be greater than what is listed for the given setting. \\n\n        Precision and minimum distance for depth detection varies with longer ranges."]
pub type PsDepthRange = ::std::os::raw::c_int;
#[doc = "!< Output both depth and RGB frames at 30 fps. The resolution of a depth frame is 640*480.\\n\n!< The resolution of an RGB frame can be set using ::PsSetFrameMode(), which supports 1600*1200/800*600/640*480."]
pub const PsDataMode_PsDepthAndRGB_30: PsDataMode = 0;
#[doc = "!< Outputs both IR and RGB frames at 30 fps. The resolution of an IR frame is 640*480.\\n\n!< The resolution of and RGB frame can be set using ::PsSetFrameMode(), which supports 1600*1200/800*600/640*480."]
pub const PsDataMode_PsIRAndRGB_30: PsDataMode = 1;
#[doc = "!< Outputs both depth and IR frames and RGB frame at 30 fps. The resolution for both depth and IR frames is 640*480.\\n\n!< The resolution of and RGB frame can be set using ::PsSetFrameMode(), which supports 1600*1200/800*600/640*480."]
pub const PsDataMode_PsDepthAndIRAndRGB_30: PsDataMode = 2;
#[doc = "!< Reserved for internal use."]
pub const PsDataMode_PsNoCCD_30: PsDataMode = 4;
#[doc = "!< WDR (Wide Dynamic Range) depth mode. Supports alternating multi-range depth frame output (e.g. Near/Far/Near/Far/Near)."]
pub const PsDataMode_PsWDR_Depth: PsDataMode = 11;
#[doc = "!< WDR (Wide Dynamic Range) IR mode. Not currently implemented."]
pub const PsDataMode_PsWDR_IR: PsDataMode = 12;
#[doc = "!< WDR (Wide Dynamic Range) Depth and IR mode. Not currently implemented."]
pub const PsDataMode_PsWDR_DepthAndIR: PsDataMode = 13;
#[doc = " @brief The data modes that determine the frame output from the device and the frame rate (fps)."]
pub type PsDataMode = ::std::os::raw::c_uint;
#[doc = "!< Gets the data mode lists that the device support"]
pub const PsPropertyType_PsPropertyDataModeList: PsPropertyType = 9;
#[doc = "!< Gets the depth range lists that the device support"]
pub const PsPropertyType_PsPropertyDepthRangeList: PsPropertyType = 10;
#[doc = " @brief Camera device properties to get or set on a device."]
pub type PsPropertyType = ::std::os::raw::c_uint;
#[doc = "!< Depth frame with 16 bits per pixel in millimeters."]
pub const PsFrameType_PsDepthFrame: PsFrameType = 0;
#[doc = "!< IR frame with 16 bits per pixel."]
pub const PsFrameType_PsIRFrame: PsFrameType = 1;
#[doc = "!< RGB frame with 24 bits per pixel in RGB/BGR format."]
pub const PsFrameType_PsRGBFrame: PsFrameType = 3;
#[doc = "!< RGB frame with 24 bits per pixel in RGB/BGR format, that is mapped to depth camera space where the resolution is the same as the depth frame's resolution.\\n\n!< This frame type can be enabled using ::PsSetMapperEnabledDepthToRGB()."]
pub const PsFrameType_PsMappedRGBFrame: PsFrameType = 4;
#[doc = "!< Depth frame with 16 bits per pixel, in millimeters, that is mapped to RGB camera space where the resolution is same as the RGB frame's resolution.\\n\n!< This frame type can be enabled using ::PsSetMapperEnabledRGBToDepth()."]
pub const PsFrameType_PsMappedDepthFrame: PsFrameType = 5;
#[doc = "!< WDR depth frame with 16 bits per pixel in millimeters. This only takes effect when the data mode set to ::PsWDR_Depth."]
pub const PsFrameType_PsWDRDepthFrame: PsFrameType = 9;
#[doc = " @brief Specifies the type of image frame."]
pub type PsFrameType = ::std::os::raw::c_uint;
#[doc = "!< Depth camera."]
pub const PsSensorType_PsDepthSensor: PsSensorType = 1;
#[doc = "!< Color (RGB) camera."]
pub const PsSensorType_PsRgbSensor: PsSensorType = 2;
#[doc = " @brief Specifies the type of camera sensor."]
pub type PsSensorType = ::std::os::raw::c_uint;
#[doc = "!< Depth image pixel format, 16 bits per pixel in mm."]
pub const PsPixelFormat_PsPixelFormatDepthMM16: PsPixelFormat = 0;
#[doc = "!< IR image pixel format, 16 bits per pixel."]
pub const PsPixelFormat_PsPixelFormatGray16: PsPixelFormat = 1;
#[doc = "!< Gray image pixel format, 8 bits per pixel."]
pub const PsPixelFormat_PsPixelFormatGray8: PsPixelFormat = 2;
#[doc = "!< Color image pixel format, 24 bits per pixel RGB format."]
pub const PsPixelFormat_PsPixelFormatRGB888: PsPixelFormat = 3;
#[doc = "!< Color image pixel format, 24 bits per pixel BGR format."]
pub const PsPixelFormat_PsPixelFormatBGR888: PsPixelFormat = 4;
#[doc = " @brief Specifies the image pixel format."]
pub type PsPixelFormat = ::std::os::raw::c_uint;
#[doc = "!< The function completed successfully."]
pub const PsReturnStatus_PsRetOK: PsReturnStatus = 0;
#[doc = "!< There is no depth camera connected or the camera has not been connected correctly. Check the hardware connection or try unplugging and re-plugging the USB cable."]
pub const PsReturnStatus_PsRetNoDeviceConnected: PsReturnStatus = -1;
#[doc = "!< The input device index is invalid."]
pub const PsReturnStatus_PsRetInvalidDeviceIndex: PsReturnStatus = -2;
#[doc = "!< The device structure pointer is null."]
pub const PsReturnStatus_PsRetDevicePointerIsNull: PsReturnStatus = -3;
#[doc = "!< The input frame type is invalid."]
pub const PsReturnStatus_PsRetInvalidFrameType: PsReturnStatus = -4;
#[doc = "!< The output frame buffer is null."]
pub const PsReturnStatus_PsRetFramePointerIsNull: PsReturnStatus = -5;
#[doc = "!< Cannot get the value for the specified property."]
pub const PsReturnStatus_PsRetNoPropertyValueGet: PsReturnStatus = -6;
#[doc = "!< Cannot set the value for the specified property."]
pub const PsReturnStatus_PsRetNoPropertyValueSet: PsReturnStatus = -7;
#[doc = "!< The input property value buffer pointer is null."]
pub const PsReturnStatus_PsRetPropertyPointerIsNull: PsReturnStatus = -8;
#[doc = "!< The input property value buffer size is too small to store the specified property value."]
pub const PsReturnStatus_PsRetPropertySizeNotEnough: PsReturnStatus = -9;
#[doc = "!< The input depth range mode is invalid."]
pub const PsReturnStatus_PsRetInvalidDepthRange: PsReturnStatus = -10;
#[doc = "!< Capture the next image frame time out."]
pub const PsReturnStatus_PsRetReadNextFrameTimeOut: PsReturnStatus = -11;
#[doc = "!< An input pointer parameter is null."]
pub const PsReturnStatus_PsRetInputPointerIsNull: PsReturnStatus = -12;
#[doc = "!< The camera has not been opened."]
pub const PsReturnStatus_PsRetCameraNotOpened: PsReturnStatus = -13;
#[doc = "!< The specified type of camera is invalid."]
pub const PsReturnStatus_PsRetInvalidCameraType: PsReturnStatus = -14;
#[doc = "!< One or more of the parameter values provided are invalid."]
pub const PsReturnStatus_PsRetInvalidParams: PsReturnStatus = -15;
#[doc = "!< This feature is not supported in the current version."]
pub const PsReturnStatus_PsRetCurrentVersionNotSupport: PsReturnStatus = -16;
#[doc = "!< There is an error in the upgrade file."]
pub const PsReturnStatus_PsRetUpgradeImgError: PsReturnStatus = -17;
#[doc = "!< Upgrade file path length greater than 260."]
pub const PsReturnStatus_PsRetUpgradeImgPathTooLong: PsReturnStatus = -18;
#[doc = "!< Ps2_SetUpgradeStatusCallback is not called."]
pub const PsReturnStatus_PsRetUpgradeCallbackNotSet: PsReturnStatus = -19;
#[doc = "!< There is no adapter connected"]
pub const PsReturnStatus_PsRetNoAdapterConnected: PsReturnStatus = -100;
#[doc = "!< The SDK has been Initialized"]
pub const PsReturnStatus_PsRetReInitialized: PsReturnStatus = -101;
#[doc = "!< The SDK has bot been Initialized"]
pub const PsReturnStatus_PsRetNoInitialized: PsReturnStatus = -102;
#[doc = "!< The camera has been opened."]
pub const PsReturnStatus_PsRetCameraOpened: PsReturnStatus = -103;
#[doc = "!< Set/Get cmd control error"]
pub const PsReturnStatus_PsRetCmdError: PsReturnStatus = -104;
#[doc = "!< Set cmd ok.but time out for the sync return"]
pub const PsReturnStatus_PsRetCmdSyncTimeOut: PsReturnStatus = -105;
#[doc = "!< IP is not in the same network segment"]
pub const PsReturnStatus_PsRetIPNotMatch: PsReturnStatus = -106;
#[doc = "!< An unknown error occurred."]
pub const PsReturnStatus_PsRetOthers: PsReturnStatus = -255;
#[doc = " @brief Return status codes for all APIs.\\n\n \t\t  <code>PsRetOK = 0</code> means the API successfully completed its operation.\\n\n \t\t  All other codes indicate a device, parameter, or API usage error."]
pub type PsReturnStatus = ::std::os::raw::c_int;
#[doc = "!< Two depth ranges."]
pub const PsWDRTotalRange_PsWDRTotalRange_Two: PsWDRTotalRange = 2;
#[doc = "!< Three depth ranges."]
pub const PsWDRTotalRange_PsWDRTotalRange_Three: PsWDRTotalRange = 3;
#[doc = " @brief Specifies the number of depth ranges defined for WDR. Currently only two or three ranges are supported (e.g. Near/Far or Near/Mid/Far)."]
pub type PsWDRTotalRange = ::std::os::raw::c_uint;
#[doc = "!< WDR image output is fused from multiple ranges."]
pub const PsWDRStyle_PsWDR_FUSION: PsWDRStyle = 0;
#[doc = "!< WDR image output alternates between depths (e.g. Near/Far/Near/Far ... )."]
pub const PsWDRStyle_PsWDR_ALTERNATION: PsWDRStyle = 1;
#[doc = " @brief The WDR style setting used for ::PsSetWDRStyle(). This determines if the WDR image output is a fusion from multiple ranges (e.g. Near/Far fusion)\\n\n or an alternative output (e.g. Near/Far/Near/Far ... )."]
pub type PsWDRStyle = ::std::os::raw::c_uint;
#[doc = "!< Depth Stream"]
pub const PsStreamType_PsStreamDepth: PsStreamType = 0;
#[doc = "!< IR Stream"]
pub const PsStreamType_PsStreamIR: PsStreamType = 1;
#[doc = "!< RGB Stream"]
pub const PsStreamType_PsStreamRGB: PsStreamType = 2;
#[doc = " @brief Stream type"]
pub type PsStreamType = ::std::os::raw::c_uint;
pub const PsResolution_PsRGB_Resolution_640_480: PsResolution = 2;
pub const PsResolution_PsRGB_Resolution_1600_1200: PsResolution = 4;
pub const PsResolution_PsRGB_Resolution_800_600: PsResolution = 5;
#[doc = "\t@brief\tResolution"]
pub type PsResolution = ::std::os::raw::c_uint;
pub const PsLinkType_LinkeUNKNOWN: PsLinkType = 0;
pub const PsLinkType_LinkUSB: PsLinkType = 1;
pub const PsLinkType_LinkSocket: PsLinkType = 2;
pub const PsLinkType_LinkMIPI: PsLinkType = 3;
pub type PsLinkType = ::std::os::raw::c_uint;
pub const PsConnectStatus_ConnectUNKNOWN: PsConnectStatus = 0;
pub const PsConnectStatus_Unconnected: PsConnectStatus = 1;
pub const PsConnectStatus_Connected: PsConnectStatus = 2;
pub const PsConnectStatus_Opened: PsConnectStatus = 3;
pub type PsConnectStatus = ::std::os::raw::c_uint;
pub const PsDeviceType_NONE: PsDeviceType = 0;
pub const PsDeviceType_DCAM305: PsDeviceType = 305;
pub const PsDeviceType_DCAM500: PsDeviceType = 500;
pub const PsDeviceType_CSI100: PsDeviceType = 501;
pub const PsDeviceType_DCAM510: PsDeviceType = 510;
pub const PsDeviceType_DCAM550U: PsDeviceType = 550;
pub const PsDeviceType_DCAM550P: PsDeviceType = 551;
pub const PsDeviceType_DCAM550E: PsDeviceType = 552;
pub const PsDeviceType_DCAM560: PsDeviceType = 560;
pub const PsDeviceType_DCAM560CPRO: PsDeviceType = 561;
pub const PsDeviceType_DCAM560CLITE: PsDeviceType = 562;
pub const PsDeviceType_DCAM710: PsDeviceType = 710;
pub const PsDeviceType_DCAM800: PsDeviceType = 800;
pub const PsDeviceType_DCAM_MIPI: PsDeviceType = 801;
pub const PsDeviceType_DCAM800LITE: PsDeviceType = 802;
pub const PsDeviceType_DCAM800LITEUSB: PsDeviceType = 803;
pub const PsDeviceType_DCAM101: PsDeviceType = 804;
pub const PsDeviceType_MAX: PsDeviceType = 805;
pub type PsDeviceType = ::std::os::raw::c_uint;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type PsDepthPixel = u16;
pub type PsGray16Pixel = u16;
pub type PsGray8Pixel = u8;
#[doc = " @brief Color image pixel type in 24-bit RGB format."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsRGB888Pixel {
    #[doc = "!< Red"]
    pub r: u8,
    #[doc = "!< Green"]
    pub g: u8,
    #[doc = "!< Blue"]
    pub b: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsRGB888Pixel"][::std::mem::size_of::<PsRGB888Pixel>() - 3usize];
    ["Alignment of PsRGB888Pixel"][::std::mem::align_of::<PsRGB888Pixel>() - 1usize];
    ["Offset of field: PsRGB888Pixel::r"][::std::mem::offset_of!(PsRGB888Pixel, r) - 0usize];
    ["Offset of field: PsRGB888Pixel::g"][::std::mem::offset_of!(PsRGB888Pixel, g) - 1usize];
    ["Offset of field: PsRGB888Pixel::b"][::std::mem::offset_of!(PsRGB888Pixel, b) - 2usize];
};
#[doc = " @brief Color image pixel type in 24-bit BGR format."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsBGR888Pixel {
    #[doc = "!< Blue"]
    pub b: u8,
    #[doc = "!< Green"]
    pub g: u8,
    #[doc = "!< Red"]
    pub r: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsBGR888Pixel"][::std::mem::size_of::<PsBGR888Pixel>() - 3usize];
    ["Alignment of PsBGR888Pixel"][::std::mem::align_of::<PsBGR888Pixel>() - 1usize];
    ["Offset of field: PsBGR888Pixel::b"][::std::mem::offset_of!(PsBGR888Pixel, b) - 0usize];
    ["Offset of field: PsBGR888Pixel::g"][::std::mem::offset_of!(PsBGR888Pixel, g) - 1usize];
    ["Offset of field: PsBGR888Pixel::r"][::std::mem::offset_of!(PsBGR888Pixel, r) - 2usize];
};
#[doc = " @brief Specifies the frame mode including the pixel format, resolution, and frame rate."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PsFrameMode {
    #[doc = "!< The pixel format used by a frame."]
    pub pixelFormat: PsPixelFormat,
    #[doc = "!< The width of the image, in pixels."]
    pub resolutionWidth: i32,
    #[doc = "!< The height of the image, in pixels."]
    pub resolutionHeight: i32,
    #[doc = "!< The image stream frame rate."]
    pub fps: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsFrameMode"][::std::mem::size_of::<PsFrameMode>() - 16usize];
    ["Alignment of PsFrameMode"][::std::mem::align_of::<PsFrameMode>() - 1usize];
    ["Offset of field: PsFrameMode::pixelFormat"]
        [::std::mem::offset_of!(PsFrameMode, pixelFormat) - 0usize];
    ["Offset of field: PsFrameMode::resolutionWidth"]
        [::std::mem::offset_of!(PsFrameMode, resolutionWidth) - 4usize];
    ["Offset of field: PsFrameMode::resolutionHeight"]
        [::std::mem::offset_of!(PsFrameMode, resolutionHeight) - 8usize];
    ["Offset of field: PsFrameMode::fps"][::std::mem::offset_of!(PsFrameMode, fps) - 12usize];
};
impl Default for PsFrameMode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Stores the x, y, and z components of a 3D vector."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsVector3f {
    #[doc = "!< The x, y, and z components of the vector."]
    pub x: f32,
    #[doc = "!< The x, y, and z components of the vector."]
    pub y: f32,
    #[doc = "!< The x, y, and z components of the vector."]
    pub z: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsVector3f"][::std::mem::size_of::<PsVector3f>() - 12usize];
    ["Alignment of PsVector3f"][::std::mem::align_of::<PsVector3f>() - 1usize];
    ["Offset of field: PsVector3f::x"][::std::mem::offset_of!(PsVector3f, x) - 0usize];
    ["Offset of field: PsVector3f::y"][::std::mem::offset_of!(PsVector3f, y) - 4usize];
    ["Offset of field: PsVector3f::z"][::std::mem::offset_of!(PsVector3f, z) - 8usize];
};
#[doc = " @brief Stores the x, y, and z components of a 2D vector."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsVector2u16 {
    pub x: u16,
    pub y: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsVector2u16"][::std::mem::size_of::<PsVector2u16>() - 4usize];
    ["Alignment of PsVector2u16"][::std::mem::align_of::<PsVector2u16>() - 1usize];
    ["Offset of field: PsVector2u16::x"][::std::mem::offset_of!(PsVector2u16, x) - 0usize];
    ["Offset of field: PsVector2u16::y"][::std::mem::offset_of!(PsVector2u16, y) - 2usize];
};
#[doc = " @brief Contains depth information for a given pixel."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsDepthVector3 {
    #[doc = "!< The x coordinate of the pixel."]
    pub depthX: ::std::os::raw::c_int,
    #[doc = "!< The y coordinate of the pixel."]
    pub depthY: ::std::os::raw::c_int,
    #[doc = "!< The depth of the pixel, in millimeters."]
    pub depthZ: PsDepthPixel,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsDepthVector3"][::std::mem::size_of::<PsDepthVector3>() - 10usize];
    ["Alignment of PsDepthVector3"][::std::mem::align_of::<PsDepthVector3>() - 1usize];
    ["Offset of field: PsDepthVector3::depthX"]
        [::std::mem::offset_of!(PsDepthVector3, depthX) - 0usize];
    ["Offset of field: PsDepthVector3::depthY"]
        [::std::mem::offset_of!(PsDepthVector3, depthY) - 4usize];
    ["Offset of field: PsDepthVector3::depthZ"]
        [::std::mem::offset_of!(PsDepthVector3, depthZ) - 8usize];
};
#[doc = " @brief Camera intrinsic parameters and distortion coefficients."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsCameraParameters {
    #[doc = "!< Focal length x (pixel)"]
    pub fx: f64,
    #[doc = "!< Focal length y (pixel)"]
    pub fy: f64,
    #[doc = "!< Principal point x (pixel)"]
    pub cx: f64,
    #[doc = "!< Principal point y (pixel)"]
    pub cy: f64,
    #[doc = "!< Radial distortion coefficient, 1st-order"]
    pub k1: f64,
    #[doc = "!< Radial distortion coefficient, 2nd-order"]
    pub k2: f64,
    #[doc = "!< Tangential distortion coefficient"]
    pub p1: f64,
    #[doc = "!< Tangential distortion coefficient"]
    pub p2: f64,
    #[doc = "!< Radial distortion coefficient, 3rd-order"]
    pub k3: f64,
    #[doc = "!< Radial distortion coefficient, 4st-order"]
    pub k4: f64,
    #[doc = "!< Radial distortion coefficient, 5nd-order"]
    pub k5: f64,
    #[doc = "!< Radial distortion coefficient, 6rd-order"]
    pub k6: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsCameraParameters"][::std::mem::size_of::<PsCameraParameters>() - 96usize];
    ["Alignment of PsCameraParameters"][::std::mem::align_of::<PsCameraParameters>() - 1usize];
    ["Offset of field: PsCameraParameters::fx"]
        [::std::mem::offset_of!(PsCameraParameters, fx) - 0usize];
    ["Offset of field: PsCameraParameters::fy"]
        [::std::mem::offset_of!(PsCameraParameters, fy) - 8usize];
    ["Offset of field: PsCameraParameters::cx"]
        [::std::mem::offset_of!(PsCameraParameters, cx) - 16usize];
    ["Offset of field: PsCameraParameters::cy"]
        [::std::mem::offset_of!(PsCameraParameters, cy) - 24usize];
    ["Offset of field: PsCameraParameters::k1"]
        [::std::mem::offset_of!(PsCameraParameters, k1) - 32usize];
    ["Offset of field: PsCameraParameters::k2"]
        [::std::mem::offset_of!(PsCameraParameters, k2) - 40usize];
    ["Offset of field: PsCameraParameters::p1"]
        [::std::mem::offset_of!(PsCameraParameters, p1) - 48usize];
    ["Offset of field: PsCameraParameters::p2"]
        [::std::mem::offset_of!(PsCameraParameters, p2) - 56usize];
    ["Offset of field: PsCameraParameters::k3"]
        [::std::mem::offset_of!(PsCameraParameters, k3) - 64usize];
    ["Offset of field: PsCameraParameters::k4"]
        [::std::mem::offset_of!(PsCameraParameters, k4) - 72usize];
    ["Offset of field: PsCameraParameters::k5"]
        [::std::mem::offset_of!(PsCameraParameters, k5) - 80usize];
    ["Offset of field: PsCameraParameters::k6"]
        [::std::mem::offset_of!(PsCameraParameters, k6) - 88usize];
};
#[doc = " @brief Specifies the camera’s location and orientation extrinsic parameters."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsCameraExtrinsicParameters {
    #[doc = "!< Orientation stored as an array of 9 double representing a 3x3 rotation matrix."]
    pub rotation: [f64; 9usize],
    #[doc = "!< Location stored as an array of 3 double representing a 3-D translation vector."]
    pub translation: [f64; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsCameraExtrinsicParameters"]
        [::std::mem::size_of::<PsCameraExtrinsicParameters>() - 96usize];
    ["Alignment of PsCameraExtrinsicParameters"]
        [::std::mem::align_of::<PsCameraExtrinsicParameters>() - 1usize];
    ["Offset of field: PsCameraExtrinsicParameters::rotation"]
        [::std::mem::offset_of!(PsCameraExtrinsicParameters, rotation) - 0usize];
    ["Offset of field: PsCameraExtrinsicParameters::translation"]
        [::std::mem::offset_of!(PsCameraExtrinsicParameters, translation) - 72usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsTimeStamp {
    pub tm_sec: u16,
    pub tm_min: u16,
    pub tm_hour: u16,
    pub tm_msec: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsTimeStamp"][::std::mem::size_of::<PsTimeStamp>() - 8usize];
    ["Alignment of PsTimeStamp"][::std::mem::align_of::<PsTimeStamp>() - 1usize];
    ["Offset of field: PsTimeStamp::tm_sec"][::std::mem::offset_of!(PsTimeStamp, tm_sec) - 0usize];
    ["Offset of field: PsTimeStamp::tm_min"][::std::mem::offset_of!(PsTimeStamp, tm_min) - 2usize];
    ["Offset of field: PsTimeStamp::tm_hour"]
        [::std::mem::offset_of!(PsTimeStamp, tm_hour) - 4usize];
    ["Offset of field: PsTimeStamp::tm_msec"]
        [::std::mem::offset_of!(PsTimeStamp, tm_msec) - 6usize];
};
#[doc = " @brief Depth/IR/RGB image frame data."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PsFrame {
    #[doc = "!< The index of the frame."]
    pub frameIndex: u32,
    #[doc = "!< The type of frame. See ::PsFrameType for more information."]
    pub frameType: PsFrameType,
    #[doc = "!< The pixel format used by a frame. See ::PsPixelFormat for more information."]
    pub pixelFormat: PsPixelFormat,
    #[doc = "!< Used to synchronize with IMU, in the range of 0 to 255."]
    pub imuFrameNo: u8,
    #[doc = "!< A buffer containing the frame’s image data."]
    pub pFrameData: *mut u8,
    #[doc = "!< The length of pFrame, in bytes."]
    pub dataLen: u32,
    #[doc = "!< The exposure time, in milliseconds."]
    pub exposureTime: f32,
    #[doc = "!< The depth range mode of the current frame. Used only for depth frames."]
    pub depthRange: PsDepthRange,
    #[doc = "!< The width of the frame, in pixels."]
    pub width: u16,
    #[doc = "!< The height of the frame, in pixels."]
    pub height: u16,
    #[doc = "!< The timestamp of the frame that decoded."]
    pub timestamp: PsTimeStamp,
    #[doc = "!< The timestamp of the camera."]
    pub hardwaretimestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsFrame"][::std::mem::size_of::<PsFrame>() - 53usize];
    ["Alignment of PsFrame"][::std::mem::align_of::<PsFrame>() - 1usize];
    ["Offset of field: PsFrame::frameIndex"][::std::mem::offset_of!(PsFrame, frameIndex) - 0usize];
    ["Offset of field: PsFrame::frameType"][::std::mem::offset_of!(PsFrame, frameType) - 4usize];
    ["Offset of field: PsFrame::pixelFormat"]
        [::std::mem::offset_of!(PsFrame, pixelFormat) - 8usize];
    ["Offset of field: PsFrame::imuFrameNo"][::std::mem::offset_of!(PsFrame, imuFrameNo) - 12usize];
    ["Offset of field: PsFrame::pFrameData"][::std::mem::offset_of!(PsFrame, pFrameData) - 13usize];
    ["Offset of field: PsFrame::dataLen"][::std::mem::offset_of!(PsFrame, dataLen) - 21usize];
    ["Offset of field: PsFrame::exposureTime"]
        [::std::mem::offset_of!(PsFrame, exposureTime) - 25usize];
    ["Offset of field: PsFrame::depthRange"][::std::mem::offset_of!(PsFrame, depthRange) - 29usize];
    ["Offset of field: PsFrame::width"][::std::mem::offset_of!(PsFrame, width) - 33usize];
    ["Offset of field: PsFrame::height"][::std::mem::offset_of!(PsFrame, height) - 35usize];
    ["Offset of field: PsFrame::timestamp"][::std::mem::offset_of!(PsFrame, timestamp) - 37usize];
    ["Offset of field: PsFrame::hardwaretimestamp"]
        [::std::mem::offset_of!(PsFrame, hardwaretimestamp) - 45usize];
};
impl Default for PsFrame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief WDR (Wide Dynamic Range) output mode settings (e.g. Near/Far range fusion)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PsWDROutputMode {
    #[doc = "!< The number of ranges supported. Currently only two or three ranges are supported (e.g. Near/Far or Near/Mid/Far)."]
    pub totalRange: PsWDRTotalRange,
    #[doc = "!< The first range."]
    pub range1: PsDepthRange,
    #[doc = "!< The count of successive <code>range1</code> frames."]
    pub range1Count: u8,
    #[doc = "!< The second range."]
    pub range2: PsDepthRange,
    #[doc = "!< The count of successive <code>range2</code> frames."]
    pub range2Count: u8,
    #[doc = "!< Third range. This range only takes effect when <code>totalRange</code> is set to <code>3</code>."]
    pub range3: PsDepthRange,
    #[doc = "!< The count of successive <code>range3</code> frames. This only takes effect when <code>totalRange</code> is set to <code>3</code>."]
    pub range3Count: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsWDROutputMode"][::std::mem::size_of::<PsWDROutputMode>() - 19usize];
    ["Alignment of PsWDROutputMode"][::std::mem::align_of::<PsWDROutputMode>() - 1usize];
    ["Offset of field: PsWDROutputMode::totalRange"]
        [::std::mem::offset_of!(PsWDROutputMode, totalRange) - 0usize];
    ["Offset of field: PsWDROutputMode::range1"]
        [::std::mem::offset_of!(PsWDROutputMode, range1) - 4usize];
    ["Offset of field: PsWDROutputMode::range1Count"]
        [::std::mem::offset_of!(PsWDROutputMode, range1Count) - 8usize];
    ["Offset of field: PsWDROutputMode::range2"]
        [::std::mem::offset_of!(PsWDROutputMode, range2) - 9usize];
    ["Offset of field: PsWDROutputMode::range2Count"]
        [::std::mem::offset_of!(PsWDROutputMode, range2Count) - 13usize];
    ["Offset of field: PsWDROutputMode::range3"]
        [::std::mem::offset_of!(PsWDROutputMode, range3) - 14usize];
    ["Offset of field: PsWDROutputMode::range3Count"]
        [::std::mem::offset_of!(PsWDROutputMode, range3Count) - 18usize];
};
impl Default for PsWDROutputMode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Specifies the GMMGain including the gain value and option type."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsGMMGain {
    #[doc = "!< The GMM gain value of the device."]
    pub gain: u16,
    #[doc = "!< The option type of setting the GMM gain effective time. 0:Immediate effect, invalid after camera closure; 1:Permanent entry into force."]
    pub option: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsGMMGain"][::std::mem::size_of::<PsGMMGain>() - 3usize];
    ["Alignment of PsGMMGain"][::std::mem::align_of::<PsGMMGain>() - 1usize];
    ["Offset of field: PsGMMGain::gain"][::std::mem::offset_of!(PsGMMGain, gain) - 0usize];
    ["Offset of field: PsGMMGain::option"][::std::mem::offset_of!(PsGMMGain, option) - 2usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsFrameReady {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsFrameReady"][::std::mem::size_of::<PsFrameReady>() - 4usize];
    ["Alignment of PsFrameReady"][::std::mem::align_of::<PsFrameReady>() - 1usize];
};
impl PsFrameReady {
    #[inline]
    pub fn depth(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_depth(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn depth_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_depth_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ir_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ir_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rgb(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rgb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rgb_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rgb_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mappedRGB(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mappedRGB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mappedRGB_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mappedRGB_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mappedDepth(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mappedDepth(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mappedDepth_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mappedDepth_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mappedIR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mappedIR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mappedIR_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mappedIR_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn confidence(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_confidence(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn confidence_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_confidence_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wdrDepth(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wdrDepth(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wdrDepth_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wdrDepth_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        depth: u32,
        ir: u32,
        rgb: u32,
        mappedRGB: u32,
        mappedDepth: u32,
        mappedIR: u32,
        confidence: u32,
        wdrDepth: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let depth: u32 = unsafe { ::std::mem::transmute(depth) };
            depth as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ir: u32 = unsafe { ::std::mem::transmute(ir) };
            ir as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rgb: u32 = unsafe { ::std::mem::transmute(rgb) };
            rgb as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mappedRGB: u32 = unsafe { ::std::mem::transmute(mappedRGB) };
            mappedRGB as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mappedDepth: u32 = unsafe { ::std::mem::transmute(mappedDepth) };
            mappedDepth as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mappedIR: u32 = unsafe { ::std::mem::transmute(mappedIR) };
            mappedIR as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let confidence: u32 = unsafe { ::std::mem::transmute(confidence) };
            confidence as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let wdrDepth: u32 = unsafe { ::std::mem::transmute(wdrDepth) };
            wdrDepth as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PsDeviceHandle = *mut ::std::os::raw::c_void;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PsDeviceInfo {
    pub SessionCount: ::std::os::raw::c_int,
    pub devicetype: PsDeviceType,
    pub uri: [::std::os::raw::c_char; 256usize],
    pub fw: [::std::os::raw::c_char; 50usize],
    pub alias: [::std::os::raw::c_char; 64usize],
    pub status: PsConnectStatus,
    pub ip: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsDeviceInfo"][::std::mem::size_of::<PsDeviceInfo>() - 398usize];
    ["Alignment of PsDeviceInfo"][::std::mem::align_of::<PsDeviceInfo>() - 1usize];
    ["Offset of field: PsDeviceInfo::SessionCount"]
        [::std::mem::offset_of!(PsDeviceInfo, SessionCount) - 0usize];
    ["Offset of field: PsDeviceInfo::devicetype"]
        [::std::mem::offset_of!(PsDeviceInfo, devicetype) - 4usize];
    ["Offset of field: PsDeviceInfo::uri"][::std::mem::offset_of!(PsDeviceInfo, uri) - 8usize];
    ["Offset of field: PsDeviceInfo::fw"][::std::mem::offset_of!(PsDeviceInfo, fw) - 264usize];
    ["Offset of field: PsDeviceInfo::alias"]
        [::std::mem::offset_of!(PsDeviceInfo, alias) - 314usize];
    ["Offset of field: PsDeviceInfo::status"]
        [::std::mem::offset_of!(PsDeviceInfo, status) - 378usize];
    ["Offset of field: PsDeviceInfo::ip"][::std::mem::offset_of!(PsDeviceInfo, ip) - 382usize];
};
impl Default for PsDeviceInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsDataModeList {
    pub count: u8,
    pub datamodelist: [u8; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsDataModeList"][::std::mem::size_of::<PsDataModeList>() - 33usize];
    ["Alignment of PsDataModeList"][::std::mem::align_of::<PsDataModeList>() - 1usize];
    ["Offset of field: PsDataModeList::count"]
        [::std::mem::offset_of!(PsDataModeList, count) - 0usize];
    ["Offset of field: PsDataModeList::datamodelist"]
        [::std::mem::offset_of!(PsDataModeList, datamodelist) - 1usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsDepthRangeList {
    pub count: u8,
    pub depthrangelist: [u8; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsDepthRangeList"][::std::mem::size_of::<PsDepthRangeList>() - 10usize];
    ["Alignment of PsDepthRangeList"][::std::mem::align_of::<PsDepthRangeList>() - 1usize];
    ["Offset of field: PsDepthRangeList::count"]
        [::std::mem::offset_of!(PsDepthRangeList, count) - 0usize];
    ["Offset of field: PsDepthRangeList::depthrangelist"]
        [::std::mem::offset_of!(PsDepthRangeList, depthrangelist) - 1usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsMeasuringRange {
    pub depthMode: u8,
    pub depthMaxNear: u16,
    pub depthMaxMid: u16,
    pub depthMaxFar: u16,
    pub effectDepthMaxNear: u16,
    pub effectDepthMaxMid: u16,
    pub effectDepthMaxFar: u16,
    pub effectDepthMinNear: u16,
    pub effectDepthMinMid: u16,
    pub effectDepthMinFar: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsMeasuringRange"][::std::mem::size_of::<PsMeasuringRange>() - 19usize];
    ["Alignment of PsMeasuringRange"][::std::mem::align_of::<PsMeasuringRange>() - 1usize];
    ["Offset of field: PsMeasuringRange::depthMode"]
        [::std::mem::offset_of!(PsMeasuringRange, depthMode) - 0usize];
    ["Offset of field: PsMeasuringRange::depthMaxNear"]
        [::std::mem::offset_of!(PsMeasuringRange, depthMaxNear) - 1usize];
    ["Offset of field: PsMeasuringRange::depthMaxMid"]
        [::std::mem::offset_of!(PsMeasuringRange, depthMaxMid) - 3usize];
    ["Offset of field: PsMeasuringRange::depthMaxFar"]
        [::std::mem::offset_of!(PsMeasuringRange, depthMaxFar) - 5usize];
    ["Offset of field: PsMeasuringRange::effectDepthMaxNear"]
        [::std::mem::offset_of!(PsMeasuringRange, effectDepthMaxNear) - 7usize];
    ["Offset of field: PsMeasuringRange::effectDepthMaxMid"]
        [::std::mem::offset_of!(PsMeasuringRange, effectDepthMaxMid) - 9usize];
    ["Offset of field: PsMeasuringRange::effectDepthMaxFar"]
        [::std::mem::offset_of!(PsMeasuringRange, effectDepthMaxFar) - 11usize];
    ["Offset of field: PsMeasuringRange::effectDepthMinNear"]
        [::std::mem::offset_of!(PsMeasuringRange, effectDepthMinNear) - 13usize];
    ["Offset of field: PsMeasuringRange::effectDepthMinMid"]
        [::std::mem::offset_of!(PsMeasuringRange, effectDepthMinMid) - 15usize];
    ["Offset of field: PsMeasuringRange::effectDepthMinFar"]
        [::std::mem::offset_of!(PsMeasuringRange, effectDepthMinFar) - 17usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsTalDelay {
    pub range: u8,
    pub value0: u16,
    pub value1: u16,
    pub value2: u16,
    pub value3: u16,
    pub value4: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsTalDelay"][::std::mem::size_of::<PsTalDelay>() - 11usize];
    ["Alignment of PsTalDelay"][::std::mem::align_of::<PsTalDelay>() - 1usize];
    ["Offset of field: PsTalDelay::range"][::std::mem::offset_of!(PsTalDelay, range) - 0usize];
    ["Offset of field: PsTalDelay::value0"][::std::mem::offset_of!(PsTalDelay, value0) - 1usize];
    ["Offset of field: PsTalDelay::value1"][::std::mem::offset_of!(PsTalDelay, value1) - 3usize];
    ["Offset of field: PsTalDelay::value2"][::std::mem::offset_of!(PsTalDelay, value2) - 5usize];
    ["Offset of field: PsTalDelay::value3"][::std::mem::offset_of!(PsTalDelay, value3) - 7usize];
    ["Offset of field: PsTalDelay::value4"][::std::mem::offset_of!(PsTalDelay, value4) - 9usize];
};
#[doc = " @brief WDR (Wide Dynamic Range) output mode settings (e.g. Near/Far range fusion)."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsWDRPulseCount {
    #[doc = "!< The pulseCount of the first range."]
    pub pulseCount1: u16,
    #[doc = "!< The pulseCount of the second range."]
    pub pulseCount2: u16,
    #[doc = "!< The pulseCount of the third range."]
    pub pulseCount3: u16,
    pub option: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsWDRPulseCount"][::std::mem::size_of::<PsWDRPulseCount>() - 7usize];
    ["Alignment of PsWDRPulseCount"][::std::mem::align_of::<PsWDRPulseCount>() - 1usize];
    ["Offset of field: PsWDRPulseCount::pulseCount1"]
        [::std::mem::offset_of!(PsWDRPulseCount, pulseCount1) - 0usize];
    ["Offset of field: PsWDRPulseCount::pulseCount2"]
        [::std::mem::offset_of!(PsWDRPulseCount, pulseCount2) - 2usize];
    ["Offset of field: PsWDRPulseCount::pulseCount3"]
        [::std::mem::offset_of!(PsWDRPulseCount, pulseCount3) - 4usize];
    ["Offset of field: PsWDRPulseCount::option"]
        [::std::mem::offset_of!(PsWDRPulseCount, option) - 6usize];
};
#[doc = " @brief WDR (Wide Dynamic Range) output mode settings (e.g. Near/Far range fusion)."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PsWDRConfidenceThreshold {
    #[doc = "!< The confidence threshold of the first range."]
    pub threshold1: u16,
    #[doc = "!< The confidence threshold of the second range."]
    pub threshold2: u16,
    #[doc = "!< The confidence threshold of the third range."]
    pub threshold3: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PsWDRConfidenceThreshold"]
        [::std::mem::size_of::<PsWDRConfidenceThreshold>() - 6usize];
    ["Alignment of PsWDRConfidenceThreshold"]
        [::std::mem::align_of::<PsWDRConfidenceThreshold>() - 1usize];
    ["Offset of field: PsWDRConfidenceThreshold::threshold1"]
        [::std::mem::offset_of!(PsWDRConfidenceThreshold, threshold1) - 0usize];
    ["Offset of field: PsWDRConfidenceThreshold::threshold2"]
        [::std::mem::offset_of!(PsWDRConfidenceThreshold, threshold2) - 2usize];
    ["Offset of field: PsWDRConfidenceThreshold::threshold3"]
        [::std::mem::offset_of!(PsWDRConfidenceThreshold, threshold3) - 4usize];
};
#[doc = " @brief hotplug status callback function\n pInfo  return the info of the Device, See ::PsDeviceInfo\n state  0:device added , 1:device removed"]
pub type PtrHotPlugStatusCallback = ::std::option::Option<
    unsafe extern "C" fn(pInfo: *const PsDeviceInfo, state: ::std::os::raw::c_int),
>;
#[doc = " @brief hotplug status callback function for c plus plus\n pInfo  return the info of the Device, See ::PsDeviceInfo\n state  0:device added , 1:device removed\n contex pointer to the object of C++ class"]
pub type PtrHotPlugStatusCallback_ = ::std::option::Option<
    unsafe extern "C" fn(
        pInfo: *const PsDeviceInfo,
        state: ::std::os::raw::c_int,
        contex: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " @brief \t\tInitializes the API on the device. This function must be invoked before any other Vzense APIs.\n @return\t\t::PsRetOK if the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_Initialize() -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tShuts down the API on the device and clears all resources allocated by the API. After invoking this function, no other Vzense APIs can be invoked.\n @return\t\t::PsRetOK\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_Shutdown() -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the number of camera devices currently connected.\n @param[out]\tpDeviceCount\tPointer to a 32-bit integer variable in which to return the device count.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetDeviceCount(pDeviceCount: *mut u32) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the info lists of the deviceCount camera devices.\n @param[in] \tdeviceCount\t\tthe number of camera devices.\n @param[out]\tpDevicesList\tPointer to a buffer in which to store the deviceCount devices infos.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetDeviceListInfo(
        pDevicesList: *mut PsDeviceInfo,
        deviceCount: u32,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the info of the deviceIndex camera device.\n @param[in] \tdeviceIndex\tThe index of the device to open. Device indices range from 0 to device count - 1.\n @param[out]\tpDevices\tPointer to a buffer in which to store the device info.\n @return \t\t::PsRetOK\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetDeviceInfo(pDevices: *mut PsDeviceInfo, deviceIndex: u32) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tOpens the device specified by <code>uri</code>. The device must be subsequently closed using PsCloseDevice().\n @param[in] \turi\t\t\tthe uri of the device. See ::PsDeviceInfo for more information.\n @param[out]\tpDevices\tthe handle of the device on which to open.\n @return: \t\t::PsRetOK\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_OpenDevice(
        uri: *const ::std::os::raw::c_char,
        pDevice: *mut PsDeviceHandle,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tCloses the device specified by <code>device</code> that was opened using PsOpenDevice.\n @param[in] \tdevice\t\tThe handle of the device to close.\n @return: \t\t::PsRetOK\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_CloseDevice(device: *mut PsDeviceHandle) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tStarts capturing the image stream indicated by <code>device</code>. \\n\nInvoke Ps2_StopStream() to stop capturing the image stream.\n @param[in] \tdevice\t\t\tThe handle of the device on which to start capturing the image stream.\n @param[in] \tsessionIndex\tThe index of the session that include N Tof sensors and maximum N RGB sensors. \\n\nrange from 0 to ::SessionCount - 1. See ::PsDeviceInfo for more information. \\n\nFor example, the camera <code>device</code> has 2 Tof sensor and 1 rgb sensor, the ::SessionCount is 2.\\n\nIf the <code>sessionIndex</code> is 0 mean that start 1 tof stream and the rgb stream, \\n\nand if the <code>sessionIndex</code> is 1 mean that start only 1 tof stream.\n @return \t    ::PsRetOK if\tthe function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_StartStream(device: PsDeviceHandle, sessionIndex: u32) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tStops capturing the image stream on the device specified by <code>device</code>. that was started using Ps2_StartStream.\n @param[in] \tdevice\t\t\tThe handle of the device on which to stop capturing the image stream.\n @param[in] \tsessionIndex\tThe index of the session that include N Tof sensors and maximum N RGB sensors. \\n\nrange from 0 to ::SessionCount - 1. See ::PsDeviceInfo for more information. \\n\nFor example, the camera <code>device</code> has 2 Tof sensor and 1 rgb sensor, the ::SessionCount is 2.\\n\nIf the <code>sessionIndex</code> is 0 mean that stop 1 tof stream and the rgb stream, \\n\nand if the <code>sessionIndex</code> is 1 mean that stop only 1 tof stream.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_StopStream(device: PsDeviceHandle, sessionIndex: u32) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tCaptures the next image frame from the device specified by <code>device</code>. This API must be invoked before capturing frame data using PsGetFrame().\n @param[in] \tdevice\t\t\tThe handle of the device on which to read the next frame.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tpFrameReady\t\tPointer to a buffer in which to store the signal on which image is ready to be get.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_ReadNextFrame(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pFrameReady: *mut PsFrameReady,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the image data for the current frame from the device specified by <code>device</code>.\\n\nBefore invoking this API, invoke PsReadNextFrame() to capture one image frame from the device.\n @param[in] \tdevice\t\t\tThe handle of the device to capture an image frame from.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tframeType\t\tThe image frame type.\n @param[out]\tpPsFrame\t\tPointer to a buffer in which to store the returned image data.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetFrame(
        device: PsDeviceHandle,
        sessionIndex: u32,
        frameType: PsFrameType,
        pPsFrame: *mut PsFrame,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief  \t\tSets the output data mode for the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device for which to set the data mode.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tdataMode\t\tThe output data mode. See ::PsDataMode for more information.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetDataMode(
        device: PsDeviceHandle,
        sessionIndex: u32,
        dataMode: PsDataMode,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief  \t\tReturns the output data mode from the device specified by <code>device</code>.\n @param[in]\tdevice\t\t\tThe handle of the device for which to set the data mode.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[Out]\tdataMode\t\tThe output data mode. See ::PsDataMode for more information.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetDataMode(
        device: PsDeviceHandle,
        sessionIndex: u32,
        dataMode: *mut PsDataMode,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the depth range mode from the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device from which to get the depth range.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tpDepthRange\t\tPointer to a ::PsDepthRange variable in which to store the returned depth range mode.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetDepthRange(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pDepthRange: *mut PsDepthRange,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the depth range mode for the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the depth range.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tdepthRange \t\tSpecifies the depth range mode.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetDepthRange(
        device: PsDeviceHandle,
        sessionIndex: u32,
        depthRange: PsDepthRange,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the threshold value for the background filter from the device specified by <code>device</code>. \\n\nThe value represents the cut-off point for distant data that the filter should ignore. \\n\nFor example, if 20.0 is specified, data with 20% or less confidence will be dropped.\n @param[in] \tdevice\t\t\tThe handle of the device from which to get the threshold.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out] \tpThreshold \t\tPointer to a 16-bit unsigned integer variable in which to return the threshold value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetThreshold(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pThreshold: *mut u16,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the threshold value for the background filter for the device specified by <code>device</code>. \\n\nThe value represents the cut-off point for distant data that the filter should ignore.  \\n\nFor example, if 20.0 is specified, data with 20% or less confidence will be dropped.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the threshold.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tthreshold\t\tThe threshold value to set. 0 will attempt to keep all point data but may not be accurate further away; 100 or higher will reject almost all point data leaving only the closest points.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetThreshold(
        device: PsDeviceHandle,
        sessionIndex: u32,
        threshold: u16,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the pulse count from the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the pulse count.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out] \tpPulseCount\t\tPointer to a 16-bit unsigned integer variable in which to store the pulse count value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetPulseCount(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pPulseCount: *mut u16,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the pulse count for the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the pulse count.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tpulseCount \t\tThe pulse count value to set.For the range 3 and 4,the value is in the range [0,260],for the other range,the value is in the range [0,600].\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetPulseCount(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pulseCount: u16,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the the device's GMM gain.\n @param[in]\tdevice\t\t\tThe handle of the device from which to get the GMM gain.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out] \tgmmgain \t\tPointer to a variable in which to store the returned GMM gain.\n @return\t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetGMMGain(
        device: PsDeviceHandle,
        sessionIndex: u32,
        gmmgain: *mut u16,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the device GMM gain on a device.\n @param[in]\tdevice\t\t\tThe handle of the device on which to set the GMM gain.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tgmmgain\t\t\tThe GMM gain value to set. See ::PsGMMGain for more information.The GMM gain value is in the range [0,4095].\n @return\t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetGMMGain(
        device: PsDeviceHandle,
        sessionIndex: u32,
        gmmgain: PsGMMGain,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns a specific property value from the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device from which to get the property value.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tpropertyType\tThe type of property to get from the device. See ::PsPropertyType for more information.\n @param[out]\tpData\t\t\tPointer to a buffer to store the returned property value.\n @param[out]\tpDataSize\t\tThe size, in bytes, of the property value returned in <code>pData</code>.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetProperty(
        device: PsDeviceHandle,
        sessionIndex: u32,
        propertyType: i32,
        pData: *mut ::std::os::raw::c_void,
        pDataSize: *mut i32,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSet the corresponding property value for the device specified by <code>device</code>.\n @param[in]\tdevice\t\t\tThe handle of the device from which to set the property value.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tpropertyType\tThe type of property to set on the device.\n @param[in]\tpData\t\t\tPointer to a buffer containing the property value.\n @param[in]\tdataSize\t\tThe size, in bytes, of the property value contained in <code>pData</code>.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetProperty(
        device: PsDeviceHandle,
        sessionIndex: u32,
        propertyType: i32,
        pData: *const ::std::os::raw::c_void,
        dataSize: i32,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the internal intrinsic and distortion coefficient parameters from the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\t\tThe handle of the device from which to get the internal parameters.\n @param[in] \tsessionIndex\t\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tsensorType\t\t\tThe type of sensor (depth or RGB) from which to get parameter information. Pass in the applicable value defined by ::PsSensorType.\n @param[out] \tpCameraParameters\tPointer to a PsCameraParameters variable in which to store the parameter values.\n @return \t\t::PsRetOK\t\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetCameraParameters(
        device: PsDeviceHandle,
        sessionIndex: u32,
        sensorType: PsSensorType,
        pCameraParameters: *mut PsCameraParameters,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the camera rotation and translation coefficient parameters from the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\t\t\t\tThe handle of the device from which to get the extrinsic parameters.\n @param[in] \tsessionIndex\t\t\t\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out] \tpCameraExtrinsicParameters \tPointer to a ::PsGetCameraExtrinsicParameters variable in which to store the parameters.\n @return \t\t::PsRetOK\t\t\t\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetCameraExtrinsicParameters(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pCameraExtrinsicParameters: *mut PsCameraExtrinsicParameters,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the color image pixel format on the device specified by <code>device</code>. Currently only RGB and BGR formats are supported.\n @param[in] \tdevice\t\t\tThe handle of the device to set the pixel format.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tpixelFormat\t\tThe color pixel format to use. Pass in one of the values defined by ::PsPixelFormat. Currently only <code>PsPixelFormatRGB888</code> and <code>PsPixelFormatBGR888</code> are supported.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetColorPixelFormat(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pixelFormat: PsPixelFormat,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the RGB frame Resolution.\n @param[in]\tdevice\t\t\tThe handle of the device on which to set the GMM gain.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tresolution\t\tThe resolution value to set. See ::PsResolution for more information.\n @return\t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetRGBResolution(
        device: PsDeviceHandle,
        sessionIndex: u32,
        resolution: PsResolution,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the the RGB frame Resolution.\n @param[in]\tdevice\t\t\tThe handle of the device from which to get the GMM gain.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out] \tresolution \t\tPointer to a variable in which to store the returned resolution.\n @return\t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetRGBResolution(
        device: PsDeviceHandle,
        sessionIndex: u32,
        resolution: *mut u16,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the WDR output mode.\n @param[in]\tdevice\t\t\tThe handle of the device on which to set the mode.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tpWDRMode \t\tThe WDR output mode to set. See ::PsWDROutputMode for more information.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetWDROutputMode(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pWDRMode: *mut PsWDROutputMode,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tGets the current WDR output mode.\n @param[in]\tdevice\t\t\tThe handle of the device on which to get the mode from.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tpWDRMode \t\tA pointer to a ::PsWDROutputMode variable in which to store the current WDR output mode.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetWDROutputMode(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pWDRMode: *mut PsWDROutputMode,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the WDR style on the device.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the WDR style.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \twdrStyle \t\tThe wide dynamic range merge style to use. See ::PsWDRStyle for more information.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetWDRStyle(
        device: PsDeviceHandle,
        sessionIndex: u32,
        wdrStyle: PsWDRStyle,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the MeasuringRange in depthRange.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the WDR style.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tdepthRange\t \tSpecifies the depth range mode.\n @param[out]\tpMeasuringRange A pointer to a ::PsMeasuringRange variable in which to store the MeasuringRange in depthRange.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetMeasuringRange(
        device: PsDeviceHandle,
        sessionIndex: u32,
        depthRange: PsDepthRange,
        pMeasuringRange: *mut PsMeasuringRange,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tConverts the input points from world coordinate space to depth coordinate space.\n @param[in]\tdevice\t\t\tThe handle of the device on which to perform the operation.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tpWorldVector \tPointer to a buffer containing the x, y, and z values of the input world coordinates to be converted, measured in millimeters.\n @param[out]\tpDepthVector \tPointer to a buffer in which to output the converted x, y, and z values of the depth coordinates. \\n\n\t\t\t\t\t\t\t\tx and y are measured in pixels, where 0, 0 is located at the top left corner of the image. \\n\n\t\t\t\t\t\t\t\tz is measured in millimeters, based on the ::PsPixelFormat depth frame.\n @param[in]\tpointCount \t\tThe number of coordinates to convert.\n @param[in]\tpCameraParam\tThe intrinsic camera parameters for the depth camera. See ::PsGetCameraParameters.\n @return\t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_ConvertWorldToDepth(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pWorldVector: *mut PsVector3f,
        pDepthVector: *mut PsDepthVector3,
        pointCount: i32,
        pCameraParam: *mut PsCameraParameters,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tConverts the input points from depth coordinate space to world coordinate space.\n @param[in] \tdevice\t\t\tThe handle of the device on which to perform the operation.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tpDepthVector \tPointer to a buffer containing the x, y, and z values of the depth coordinates to be converted. \\n\n      \t\t\t\t\t\t\t x and y are measured in pixels, where 0, 0 is located at the top left corner of the image. \\n\n\t                            z is measured in millimeters, based on the ::PsPixelFormat depth frame.\n @param[out] \tpWorldVector \tPointer to a buffer in which to output the converted x, y, and z values of the world coordinates, measured in millimeters.\n @param[in] \tpointCount \t\tThe number of points to convert.\n @param[in]\tpCameraParam\tThe intrinsic camera parameters for the depth camera. See ::PsGetCameraParameters.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_ConvertDepthToWorld(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pDepthVector: *mut PsDepthVector3,
        pWorldVector: *mut PsVector3f,
        pointCount: i32,
        pCameraParam: *mut PsCameraParameters,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tConverts the input Depth frame from depth coordinate space to world coordinate space on the device.\n @param[in] \tdevice\t\t\tThe handle of the device on which to perform the operation.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tdepthFrame\t\tThe depth frame.\n @param[out] \tpWorldVector \tPointer to a buffer in which to output the converted x, y, and z values of the world coordinates, measured in millimeters.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_ConvertDepthFrameToWorldVector(
        device: PsDeviceHandle,
        sessionIndex: u32,
        depthFrame: PsFrame,
        pWorldVector: *mut PsVector3f,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the syncronize feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetSynchronizeEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the Boolean value of whether the syncronize feature is enabled or disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tbEnabled\t\tPointer to a variable in which to store the returned Boolean value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetSynchronizeEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tEnables or disables the depth and ir distortion correction feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetDepthDistortionCorrectionEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the Boolean value of whether the depth and ir distortion correction feature is enabled or disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tbEnabled\t\tPointer to a variable in which to store the returned Boolean value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetDepthDistortionCorrectionEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tEnables or disables the RGB distortion correction feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetRGBDistortionCorrectionEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the Boolean value of whether the RGB distortion correction feature is enabled or disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tbEnabled\t\tPointer to a variable in which to store the returned Boolean value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetRGBDistortionCorrectionEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the ComputeRealDepth feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetComputeRealDepthCorrectionEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the Boolean value of whether the ComputeRealDepth feature is enabled or disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tbEnabled\t\tPointer to a variable in which to store the returned Boolean value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetComputeRealDepthCorrectionEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the SpatialFilter feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetSpatialFilterEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the Boolean value of whether the SpatialFilter feature is enabled or disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tbEnabled\t\tPointer to a variable in which to store the returned Boolean value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetSpatialFilterEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the TimeFilter feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetTimeFilterEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the Boolean value of whether the TimeFilter feature is enabled or disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tbEnabled\t\tPointer to a variable in which to store the returned Boolean value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetTimeFilterEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the Depth Stream feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetDepthFrameEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the IR Stream feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetIrFrameEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the RGB Stream feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetRgbFrameEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tSets the ImageMirror feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\ttype\t\t\t1 left-right mirror; 2 up-down mirror;3 both mirror (rotation 180)\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetImageMirror(
        device: PsDeviceHandle,
        sessionIndex: u32,
        type_: i32,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tSets the ImageRotation feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\ttype\t\t\t0 counterclock 906у; 1 counterclock 1806у;2 counterclock 2706у\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetImageRotation(
        device: PsDeviceHandle,
        sessionIndex: u32,
        type_: i32,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tEnables or disables mapping of the depth image to RGB space on the device. When enabled, PsGetFrame() can\\n\n        \t\tbe invoked passing ::PsMappedRGBFrame as the frame type, to get the depth frame that is mapped to RGB space. The resolution of\\n\n        \t\tthe mapped rgb frame is the same as that of the depth image.\n @param[in] \tdevice\t\t\tThe handle of the device on which to enable or disable mapping.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tbEnabled \t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetMapperEnabledDepthToRGB(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the Boolean value of whether the mapping of the depth image to RGB space feature is enabled or disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tbEnabled\t\tPointer to a variable in which to store the returned Boolean value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetMapperEnabledDepthToRGB(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tEnables or disables mapping of the RGB image to depth space on the device. When enabled, PsGetFrame()\\n\ncan be invoked passing ::PsMappedDepthFrame as the frame type, to get the RGB frame that is mapped to depth space. The resolution\\n\nof the mapped depth frame is the same as that of the RGB image.\n @param[in] \tdevice\t\t\tThe handle of the device on which to enable or disable mapping.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tbEnabled \t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetMapperEnabledRGBToDepth(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the Boolean value of whether the mapping of the RGB image to depth space feature is enabled or disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tbEnabled\t\tPointer to a variable in which to store the returned Boolean value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetMapperEnabledRGBToDepth(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets hotplug status callback function\n @param[in]\tpCallback\t\tPointer to the callback function. See ::PtrHotPlugStatusCallback\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetHotPlugStatusCallback(pCallback: PtrHotPlugStatusCallback) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets hotplug status callback function for c plus plus\n @param[in]\tpCallback\t\tPointer to the callback function. See ::PtrHotPlugStatusCallback\n @param[in]\tcontex\t\t    Pointer to the object of C++ class\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetHotPlugStatusCallback_(
        pCallback: PtrHotPlugStatusCallback_,
        contex: *mut ::std::os::raw::c_void,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the pulse count from the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the pulse count.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out] \tpwdrPulseCount\tA pointer to a ::PsWDRPulseCount variable in which to store the PulseCount in WDR mode.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetWDRPulseCount(
        device: PsDeviceHandle,
        sessionIndex: u32,
        pwdrPulseCount: *mut PsWDRPulseCount,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the pulse count for the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the pulse count.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tpwdrPulseCount \tThe PulseCount value in WDR mode to set.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetWDRPulseCount(
        device: PsDeviceHandle,
        sessionIndex: u32,
        wdrpulseCount: PsWDRPulseCount,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the serial number.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the pulse count.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tsn \t\t\t\tPointer to a variable in which to store the returned sn value.\n @param[in] \tlength \t\t\tThe maximum length is 63 bytes.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetSerialNumber(
        device: PsDeviceHandle,
        sessionIndex: u32,
        sn: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the firmware version number.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the pulse count.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tfw \t\t\t\tPointer to a variable in which to store the returned fw value.\n @param[in] \tlength \t\t\tThe maximum length is 63 bytes.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetFirmwareVersionNumber(
        device: PsDeviceHandle,
        sessionIndex: u32,
        fw: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the DSP feature for tof frame.\n\t\t\t\tThe DSP feature only support ComputeRealDepthCorrection and SpatialFilter.\n\t            The default filter has ComputeRealDepthCorrection, SpatialFilter,TimeFilter, DepthDistortionCorrection and IrDistortionCorrection.\n\t\t\t\tEnable the DSP feature can reduce SDK loading, but disable it has a better effect.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetDSPEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tReturns the Boolean value of whether the DSP feature is enabled or disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tbEnabled\t\tPointer to a variable in which to store the returned Boolean value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetDSPEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    pub fn Ps2_SetSlaveModeEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the tof frame rate.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the pulse count.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tvalue \t\t    The value of rate,in 3,5,6,10,15,30.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetTofFrameRate(
        device: PsDeviceHandle,
        sessionIndex: u32,
        value: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the tof frame rate.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the pulse count.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tvalue \t\t    The rate value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetTofFrameRate(
        device: PsDeviceHandle,
        sessionIndex: u32,
        value: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the StandBy feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetStandByEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        bEnabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tOpens the device specified by <code>alias</code>. The device must be subsequently closed using PsCloseDevice().\n @param[in] \talias\t\tthe alias of the device. See ::PsDeviceInfo for more information.\n @param[out]\tpDevices\tthe handle of the device on which to open.\n @return: \t\t::PsRetOK\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_OpenDeviceByAlias(
        alias: *const ::std::os::raw::c_char,
        pDevice: *mut PsDeviceHandle,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSet the waittime of read next frame.\n @param[in] \tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \ttime \t\t\tThe unit is millisecond, the value is in the range (0,65535) and the default value is 350 millisecond.\n You can change the value according to the frame rate. For example,the frame rate is 30, so the theoretical waittime interval is 33ms, but if set the time value is 20ms,\n it means the max wait time is 20 ms when capturing next frame, so when call the Ps2_ReadNextFrame, it may return PsRetReadNextFrameTimeOut(-11).\n so the value range that recommended is [50.350].\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetWaitTimeOfReadNextFrame(
        device: PsDeviceHandle,
        sessionIndex: u32,
        time: u16,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the version of SDK.\n @param[in] \tversion \t\tPointer to a variable in which to store the returned version value.\n @param[in] \tlength \t\t\tThe maximum length is 63 bytes.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetSDKVersion(
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the point value of the frame that the mapping of the depth image to RGB space.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tpointInDepth\tThe point in depth frame.\n @param[in]\trgbSize\t\t\tThe size(x = w,y = h) of rgb frame.\n\n @param[out]\tpPointInRGB\t\tThe point in the rgb frame.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetMappedPointDepthToRGB(
        device: PsDeviceHandle,
        sessionIndex: u32,
        depthPoint: PsDepthVector3,
        rgbSize: PsVector2u16,
        pPosInRGB: *mut PsVector2u16,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tTrigger frame data once in slave mode.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetSlaveTrigger(device: PsDeviceHandle, sessionIndex: u32) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets IP from the device specified by <code>uri</code>.\n @param[in] \turi\t\t\tthe uri of the device. See ::PsDeviceInfo for more information.\n @param[out]\tip\t\t\tPointer to a buffer in which to store the device IP. the buffer default size is 17, and the last buffer set '\\0'.\n @return: \t\t::PsRetOK\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetDeviceIP(
        uri: *const ::std::os::raw::c_char,
        ip: *mut ::std::os::raw::c_char,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the MAC from the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device.\n @param[in] \tsessionIndex\tThe index of the session.\n @param[out]\tmac\t\t\t\tPointer to a buffer in which to store the device MAC. the buffer default size is 18, and the last buffer set '\\0'.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetDeviceMAC(
        device: PsDeviceHandle,
        sessionIndex: u32,
        mac: *mut ::std::os::raw::c_char,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the RGB brightness.\n @param[in] \tdevice\t\t\tThe handle of the device.\n @param[in] \tsessionIndex\tThe index of the session.\n @param[in]\tvalue\t\t\tThe value of brightness,in [-64,64].\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetRGBBrightness(
        device: PsDeviceHandle,
        sessionIndex: u32,
        value: ::std::os::raw::c_char,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the RGB brightness.\n @param[in] \tdevice\t\t\tThe handle of the device.\n @param[in] \tsessionIndex\tThe index of the session.\n @param[out]\tvalue\t\t\tThe value of brightness,in [-64,64].\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetRGBBrightness(
        device: PsDeviceHandle,
        sessionIndex: u32,
        value: *mut ::std::os::raw::c_char,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the maximum exposure time of RGB in AEC.\n @param[in] \tdevice\t\t\tThe handle of the device.\n @param[in] \tsessionIndex\tThe index of the session.\n @param[in]\tvalue\t\t\tThe value of brightness,in [1,30] and the unit is 1ms.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetRGBMaximumExposureTime(
        device: PsDeviceHandle,
        sessionIndex: u32,
        value: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the maximum exposure time  of RGB in AEC.\n @param[in] \tdevice\t\t\tThe handle of the device.\n @param[in] \tsessionIndex\tThe index of the session.\n @param[out]\tvalue\t\t\tThe value of brightness,in [1,30] and the unit is 1ms.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetRGBMaximumExposureTime(
        device: PsDeviceHandle,
        sessionIndex: u32,
        value: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the RGB frequency of power line.\n @param[in] \tdevice\t\t\tThe handle of the device.\n @param[in] \tsessionIndex\tThe index of the session.\n @param[in]\tvalue\t\t\tThe frequency value of power line, 1:50HZ 2:60HZ\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetRGBFrequencyOfPowerLine(
        device: PsDeviceHandle,
        sessionIndex: u32,
        value: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the RGB frequency of power line.\n @param[in] \tdevice\t\t\tThe handle of the device.\n @param[in] \tsessionIndex\tThe index of the session.\n @param[out]\tvalue\t\t\tThe frequency value of power line, 1:50HZ 2:60HZ\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetRGBFrequencyOfPowerLine(
        device: PsDeviceHandle,
        sessionIndex: u32,
        value: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tReboot the camera.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_RebootCamera(device: PsDeviceHandle, sessionIndex: u32) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the legacy algorithmic,and default value is disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetLegacyAlgorithmicEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        enabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the ConfidenceFilter feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetConfidenceFilterEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        enabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the Boolean value of whether the ConfidenceFilter feature is enabled or disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tbEnabled\t\tPointer to a variable in which to store the returned Boolean value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetConfidenceFilterEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        enabled: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the ConfidenceFilter threshold value for the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the threshold.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tthreshold\t\tThe threshold value to set. 0 will attempt to keep all point data but may not be accurate further away; 1000 is the max value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetConfidenceFilterThreshold(
        device: PsDeviceHandle,
        sessionIndex: u32,
        threshold: u16,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the ConfidenceFilter threshold value for the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the threshold.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tthreshold\t\tThe threshold value to set. 0 will attempt to keep all point data but may not be accurate further away; 1000 is the max value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetConfidenceFilterThreshold(
        device: PsDeviceHandle,
        sessionIndex: u32,
        threshold: *mut u16,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the WDR ConfidenceFilter threshold value for the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the threshold.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tthreshold\t\tThe threshold value to set. 0 will attempt to keep all point data but may not be accurate further away; 1000 is the max value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetWDRConfidenceFilterThreshold(
        device: PsDeviceHandle,
        sessionIndex: u32,
        wdrconfidencethreshold: PsWDRConfidenceThreshold,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the WDR ConfidenceFilter threshold value for the device specified by <code>device</code>.\n @param[in] \tdevice\t\t\tThe handle of the device on which to set the threshold.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in] \tthreshold\t\tThe threshold value to set. 0 will attempt to keep all point data but may not be accurate further away; 1000 is the max value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetWDRConfidenceFilterThreshold(
        device: PsDeviceHandle,
        sessionIndex: u32,
        wdrconfidencethreshold: *mut PsWDRConfidenceThreshold,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tOpens the device specified by <code>ip</code>. The device must be subsequently closed using PsCloseDevice().\n @param[in] \tip\t\t\tthe ip of the device. See ::PsDeviceInfo for more information.\n @param[out]\tpDevices\tthe handle of the device on which to open.\n @return: \t\t::PsRetOK\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_OpenDeviceByIP(
        ip: *const ::std::os::raw::c_char,
        pDevice: *mut PsDeviceHandle,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief\t\tEnables or disables the RGB manual exposure feature.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[in]\tbEnabled\t\tSet to <code>true</code> to enable the feature or <code>false</code> to disable the feature.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetRGBManualExposureEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        enabled: u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tReturns the Boolean value of whether the RGB manual exposure feature is enabled or disabled.\n @param[in]\tdevice\t\t\tThe handle of the device on which to enable or disable the feature.\n @param[in] \tsessionIndex\tThe index of the session. See ::Ps2_StartStream() & ::Ps2_StopStream() api for more information.\n @param[out]\tbEnabled\t\tPointer to a variable in which to store the returned Boolean value.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetRGBManualExposureEnabled(
        device: PsDeviceHandle,
        sessionIndex: u32,
        enabled: *mut u8,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tSets the RGB absolute exposure in manual.\n @param[in] \tdevice\t\t\tThe handle of the device.\n @param[in] \tsessionIndex\tThe index of the session.\n @param[in]\tvalue\t\t\tThe value of brightness,in [1,4000] and the unit is 100us.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_SetRGBAbsoluteExposure(
        device: PsDeviceHandle,
        sessionIndex: u32,
        value: u16,
    ) -> PsReturnStatus;
}
unsafe extern "C" {
    #[doc = " @brief \t\tGets the RGB absolute exposure in manual.\n @param[in] \tdevice\t\t\tThe handle of the device.\n @param[in] \tsessionIndex\tThe index of the session.\n @param[out]\tvalue\t\t\tThe value of brightness,in [1,4000] and the unit is 100us.\n @return \t\t::PsRetOK\t\tif the function succeeded, or one of the error values defined by ::PsReturnStatus."]
    pub fn Ps2_GetRGBAbsoluteExposure(
        device: PsDeviceHandle,
        sessionIndex: u32,
        value: *mut u16,
    ) -> PsReturnStatus;
}
